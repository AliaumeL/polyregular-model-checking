-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Parser.HighLevelForProgram.Par
  ( happyError
  , myLexer
  , pProgram
  , pListFunc
  , pFunc
  , pStmt
  , pListStmt
  , pExpr3
  , pExpr2
  , pExpr1
  , pExpr
  , pListExpr
  , pType1
  , pType2
  , pType
  , pVEArg
  , pListIdent
  , pListVEArg
  , pArgD
  , pListArgD
  , pBinOp
  ) where

import Prelude

import qualified Parser.HighLevelForProgram.Abs
import Parser.HighLevelForProgram.Lex

}

%name pProgram Program
%name pListFunc ListFunc
%name pFunc Func
%name pStmt Stmt
%name pListStmt ListStmt
%name pExpr3 Expr3
%name pExpr2 Expr2
%name pExpr1 Expr1
%name pExpr Expr
%name pListExpr ListExpr
%name pType1 Type1
%name pType2 Type2
%name pType Type
%name pVEArg VEArg
%name pListIdent ListIdent
%name pListVEArg ListVEArg
%name pArgD ArgD
%name pListArgD ListArgD
%name pBinOp BinOp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)  }
  '('        { PT _ (TS _ 2)  }
  ')'        { PT _ (TS _ 3)  }
  ','        { PT _ (TS _ 4)  }
  ':'        { PT _ (TS _ 5)  }
  ':='       { PT _ (TS _ 6)  }
  '<'        { PT _ (TS _ 7)  }
  '<='       { PT _ (TS _ 8)  }
  '='        { PT _ (TS _ 9)  }
  '==='      { PT _ (TS _ 10) }
  '>'        { PT _ (TS _ 11) }
  '>='       { PT _ (TS _ 12) }
  'Bool'     { PT _ (TS _ 13) }
  'Char'     { PT _ (TS _ 14) }
  'False'    { PT _ (TS _ 15) }
  'True'     { PT _ (TS _ 16) }
  '['        { PT _ (TS _ 17) }
  ']'        { PT _ (TS _ 18) }
  'and'      { PT _ (TS _ 19) }
  'def'      { PT _ (TS _ 20) }
  'do'       { PT _ (TS _ 21) }
  'done'     { PT _ (TS _ 22) }
  'else'     { PT _ (TS _ 23) }
  'endif'    { PT _ (TS _ 24) }
  'for'      { PT _ (TS _ 25) }
  'if'       { PT _ (TS _ 26) }
  'in'       { PT _ (TS _ 27) }
  'let'      { PT _ (TS _ 28) }
  'mut'      { PT _ (TS _ 29) }
  'not'      { PT _ (TS _ 30) }
  'or'       { PT _ (TS _ 31) }
  'return'   { PT _ (TS _ 32) }
  'reversed' { PT _ (TS _ 33) }
  'setTrue'  { PT _ (TS _ 34) }
  'then'     { PT _ (TS _ 35) }
  'with'     { PT _ (TS _ 36) }
  'yield'    { PT _ (TS _ 37) }
  '{'        { PT _ (TS _ 38) }
  '|'        { PT _ (TS _ 39) }
  '}'        { PT _ (TS _ 40) }
  L_Ident    { PT _ (TV $$)   }
  L_charac   { PT _ (TC $$)   }
  L_quoted   { PT _ (TL $$)   }

%%

Ident :: { Parser.HighLevelForProgram.Abs.Ident }
Ident  : L_Ident { Parser.HighLevelForProgram.Abs.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

String  :: { String }
String   : L_quoted { $1 }

Program :: { Parser.HighLevelForProgram.Abs.Program }
Program : ListFunc { Parser.HighLevelForProgram.Abs.ProgramC $1 }

ListFunc :: { [Parser.HighLevelForProgram.Abs.Func] }
ListFunc : Func { (:[]) $1 } | Func ListFunc { (:) $1 $2 }

Func :: { Parser.HighLevelForProgram.Abs.Func }
Func
  : 'def' Ident '(' ListArgD ')' ':' Type ':=' ListStmt { Parser.HighLevelForProgram.Abs.FuncC $2 $4 $7 $9 }

Stmt :: { Parser.HighLevelForProgram.Abs.Stmt }
Stmt
  : 'for' '(' Ident ',' Ident ')' 'in' Expr 'do' ListStmt 'done' { Parser.HighLevelForProgram.Abs.SFor $3 $5 $8 $10 }
  | 'if' Expr 'then' ListStmt 'endif' { Parser.HighLevelForProgram.Abs.SIf $2 $4 }
  | 'if' Expr 'then' ListStmt 'else' ListStmt 'endif' { Parser.HighLevelForProgram.Abs.SIfE $2 $4 $6 }
  | 'yield' Expr { Parser.HighLevelForProgram.Abs.SYield $2 }
  | 'return' Expr { Parser.HighLevelForProgram.Abs.SReturn $2 }
  | 'let' Ident ':' Type ':=' Expr 'in' Stmt { Parser.HighLevelForProgram.Abs.SLetIn $2 $4 $6 $8 }
  | 'let' 'mut' Ident ':' Type ':=' 'False' 'in' Stmt { Parser.HighLevelForProgram.Abs.SLetBIn $3 $5 $9 }
  | 'setTrue' Ident { Parser.HighLevelForProgram.Abs.SLetSetTrue $2 }

ListStmt :: { [Parser.HighLevelForProgram.Abs.Stmt] }
ListStmt : Stmt { (:[]) $1 } | Stmt ListStmt { (:) $1 $2 }

Expr3 :: { Parser.HighLevelForProgram.Abs.Expr }
Expr3
  : Char { Parser.HighLevelForProgram.Abs.VEChar $1 }
  | String { Parser.HighLevelForProgram.Abs.VEString $1 }
  | '[' ListExpr ']' { Parser.HighLevelForProgram.Abs.VEListConstr $2 }
  | '{' Type '|' Stmt '|' '}' { Parser.HighLevelForProgram.Abs.VEGen $2 $4 }
  | Ident { Parser.HighLevelForProgram.Abs.VEVal $1 }
  | 'reversed' '(' Expr ')' { Parser.HighLevelForProgram.Abs.VERev $3 }
  | Ident '(' ListVEArg ')' { Parser.HighLevelForProgram.Abs.VEFunc $1 $3 }
  | 'True' { Parser.HighLevelForProgram.Abs.BETrue }
  | 'False' { Parser.HighLevelForProgram.Abs.BEFalse }
  | 'not' Expr3 { Parser.HighLevelForProgram.Abs.BENot $2 }
  | '(' Expr ')' { $2 }

Expr2 :: { Parser.HighLevelForProgram.Abs.Expr }
Expr2
  : Expr3 BinOp Expr3 { Parser.HighLevelForProgram.Abs.BEBinOp $1 $2 $3 }
  | Expr3 { $1 }

Expr1 :: { Parser.HighLevelForProgram.Abs.Expr }
Expr1
  : Expr2 'and' Expr1 { Parser.HighLevelForProgram.Abs.BEAnd $1 $3 }
  | Expr2 { $1 }

Expr :: { Parser.HighLevelForProgram.Abs.Expr }
Expr
  : Expr1 'or' Expr { Parser.HighLevelForProgram.Abs.BEOr $1 $3 }
  | Expr1 { $1 }

ListExpr :: { [Parser.HighLevelForProgram.Abs.Expr] }
ListExpr : Expr { (:[]) $1 } | Expr ',' ListExpr { (:) $1 $3 }

Type1 :: { Parser.HighLevelForProgram.Abs.Type }
Type1
  : 'Char' { Parser.HighLevelForProgram.Abs.TChar }
  | '[' Type ']' { Parser.HighLevelForProgram.Abs.TList $2 }

Type2 :: { Parser.HighLevelForProgram.Abs.Type }
Type2 : 'Bool' { Parser.HighLevelForProgram.Abs.TBool }

Type :: { Parser.HighLevelForProgram.Abs.Type }
Type : Type1 { $1 } | Type2 { $1 }

VEArg :: { Parser.HighLevelForProgram.Abs.VEArg }
VEArg
  : Expr { Parser.HighLevelForProgram.Abs.VEArgSole $1 }
  | Expr 'with' '(' ListIdent ')' { Parser.HighLevelForProgram.Abs.VEArgWithPoses $1 $4 }

ListIdent :: { [Parser.HighLevelForProgram.Abs.Ident] }
ListIdent : Ident { (:[]) $1 } | Ident ',' ListIdent { (:) $1 $3 }

ListVEArg :: { [Parser.HighLevelForProgram.Abs.VEArg] }
ListVEArg
  : {- empty -} { [] }
  | VEArg { (:[]) $1 }
  | VEArg ',' ListVEArg { (:) $1 $3 }

ArgD :: { Parser.HighLevelForProgram.Abs.ArgD }
ArgD
  : Ident ':' Type { Parser.HighLevelForProgram.Abs.ArgDSole $1 $3 }
  | Ident ':' Type 'with' '(' ListIdent ')' { Parser.HighLevelForProgram.Abs.ArgDWithPoses $1 $3 $6 }

ListArgD :: { [Parser.HighLevelForProgram.Abs.ArgD] }
ListArgD
  : {- empty -} { [] }
  | ArgD { (:[]) $1 }
  | ArgD ',' ListArgD { (:) $1 $3 }

BinOp :: { Parser.HighLevelForProgram.Abs.BinOp }
BinOp
  : '=' { Parser.HighLevelForProgram.Abs.BinOpEq }
  | '!=' { Parser.HighLevelForProgram.Abs.BinOpNeq }
  | '<=' { Parser.HighLevelForProgram.Abs.BinOpLeq }
  | '<' { Parser.HighLevelForProgram.Abs.BinOpLt }
  | '>=' { Parser.HighLevelForProgram.Abs.BinOpGeq }
  | '>' { Parser.HighLevelForProgram.Abs.BinOpGt }
  | '===' { Parser.HighLevelForProgram.Abs.BinOpVEq }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

