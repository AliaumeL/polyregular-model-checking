-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Parser.SimpleForProgram.Par
  ( happyError
  , myLexer
  , pListStmt
  , pListIdentHash
  , pProgram
  , pVarStmt
  , pFORInput
  , pStmt
  , pBExpr2
  , pBExpr1
  , pBExpr
  , pBTest
  ) where

import Prelude

import qualified Parser.SimpleForProgram.Abs
import Parser.SimpleForProgram.Lex

}

%name pListStmt ListStmt
%name pListIdentHash ListIdentHash
%name pProgram Program
%name pVarStmt VarStmt
%name pFORInput FORInput
%name pStmt Stmt
%name pBExpr2 BExpr2
%name pBExpr1 BExpr1
%name pBExpr BExpr
%name pBTest BTest
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='        { PT _ (TS _ 1)         }
  '('         { PT _ (TS _ 2)         }
  ')'         { PT _ (TS _ 3)         }
  ','         { PT _ (TS _ 4)         }
  ':='        { PT _ (TS _ 5)         }
  '<'         { PT _ (TS _ 6)         }
  '<='        { PT _ (TS _ 7)         }
  '=='        { PT _ (TS _ 8)         }
  '>'         { PT _ (TS _ 9)         }
  '>='        { PT _ (TS _ 10)        }
  'and'       { PT _ (TS _ 11)        }
  'do'        { PT _ (TS _ 12)        }
  'done'      { PT _ (TS _ 13)        }
  'else'      { PT _ (TS _ 14)        }
  'endif'     { PT _ (TS _ 15)        }
  'false'     { PT _ (TS _ 16)        }
  'for'       { PT _ (TS _ 17)        }
  'if'        { PT _ (TS _ 18)        }
  'in'        { PT _ (TS _ 19)        }
  'input'     { PT _ (TS _ 20)        }
  'label'     { PT _ (TS _ 21)        }
  'let'       { PT _ (TS _ 22)        }
  'not'       { PT _ (TS _ 23)        }
  'or'        { PT _ (TS _ 24)        }
  'print'     { PT _ (TS _ 25)        }
  'reversed'  { PT _ (TS _ 26)        }
  'skip'      { PT _ (TS _ 27)        }
  'then'      { PT _ (TS _ 28)        }
  'true'      { PT _ (TS _ 29)        }
  L_charac    { PT _ (TC $$)          }
  L_IdentHash { PT _ (T_IdentHash $$) }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

IdentHash :: { Parser.SimpleForProgram.Abs.IdentHash }
IdentHash  : L_IdentHash { Parser.SimpleForProgram.Abs.IdentHash $1 }

ListStmt :: { [Parser.SimpleForProgram.Abs.Stmt] }
ListStmt : Stmt { (:[]) $1 } | Stmt ListStmt { (:) $1 $2 }

ListIdentHash :: { [Parser.SimpleForProgram.Abs.IdentHash] }
ListIdentHash
  : IdentHash { (:[]) $1 }
  | IdentHash ',' ListIdentHash { (:) $1 $3 }

Program :: { Parser.SimpleForProgram.Abs.Program }
Program : VarStmt { Parser.SimpleForProgram.Abs.Program $1 }

VarStmt :: { Parser.SimpleForProgram.Abs.VarStmt }
VarStmt
  : 'let' ListIdentHash ':=' 'false' 'in' ListStmt { Parser.SimpleForProgram.Abs.VarStmt $2 $6 }
  | ListStmt { Parser.SimpleForProgram.Abs.NoVarStmt $1 }

FORInput :: { Parser.SimpleForProgram.Abs.FORInput }
FORInput
  : 'input' { Parser.SimpleForProgram.Abs.FInput }
  | 'reversed' '(' 'input' ')' { Parser.SimpleForProgram.Abs.FRevInput }

Stmt :: { Parser.SimpleForProgram.Abs.Stmt }
Stmt
  : 'for' IdentHash 'in' FORInput 'do' VarStmt 'done' { Parser.SimpleForProgram.Abs.SFor $2 $4 $6 }
  | IdentHash ':=' 'true' { Parser.SimpleForProgram.Abs.SSetTrue $1 }
  | 'if' BExpr 'then' ListStmt 'else' ListStmt 'endif' { Parser.SimpleForProgram.Abs.SIfElse $2 $4 $6 }
  | 'if' BExpr 'then' ListStmt 'endif' { Parser.SimpleForProgram.Abs.SIf $2 $4 }
  | 'print' Char { Parser.SimpleForProgram.Abs.SPrintChar $2 }
  | 'print' IdentHash { Parser.SimpleForProgram.Abs.SPrintLabel $2 }
  | 'skip' { Parser.SimpleForProgram.Abs.SSkip }

BExpr2 :: { Parser.SimpleForProgram.Abs.BExpr }
BExpr2
  : 'true' { Parser.SimpleForProgram.Abs.BTrue }
  | 'false' { Parser.SimpleForProgram.Abs.BFalse }
  | IdentHash { Parser.SimpleForProgram.Abs.BVar $1 }
  | 'not' BExpr2 { Parser.SimpleForProgram.Abs.BNot $2 }
  | IdentHash BTest IdentHash { Parser.SimpleForProgram.Abs.BTest $1 $2 $3 }
  | 'label' '(' IdentHash ')' '==' Char { Parser.SimpleForProgram.Abs.BLabelAt $3 $6 }
  | '(' BExpr ')' { $2 }

BExpr1 :: { Parser.SimpleForProgram.Abs.BExpr }
BExpr1
  : BExpr2 'and' BExpr1 { Parser.SimpleForProgram.Abs.BAnd $1 $3 }
  | BExpr2 { $1 }

BExpr :: { Parser.SimpleForProgram.Abs.BExpr }
BExpr
  : BExpr1 'or' BExpr { Parser.SimpleForProgram.Abs.BOr $1 $3 }
  | BExpr1 { $1 }

BTest :: { Parser.SimpleForProgram.Abs.BTest }
BTest
  : '<=' { Parser.SimpleForProgram.Abs.TLe }
  | '<' { Parser.SimpleForProgram.Abs.TLt }
  | '>=' { Parser.SimpleForProgram.Abs.TGe }
  | '>' { Parser.SimpleForProgram.Abs.TGt }
  | '==' { Parser.SimpleForProgram.Abs.TEq }
  | '!=' { Parser.SimpleForProgram.Abs.TNeq }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

