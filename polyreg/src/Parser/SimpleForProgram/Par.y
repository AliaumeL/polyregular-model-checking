-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Parser.SimpleForProgram.Par
  ( happyError
  , myLexer
  , pListStmt
  , pListIdent
  , pProgram
  , pVarStmt
  , pFORInput
  , pStmt
  , pBExpr2
  , pBExpr1
  , pBExpr
  , pBTest
  ) where

import Prelude

import qualified Parser.SimpleForProgram.Abs
import Parser.SimpleForProgram.Lex

}

%name pListStmt ListStmt
%name pListIdent ListIdent
%name pProgram Program
%name pVarStmt VarStmt
%name pFORInput FORInput
%name pStmt Stmt
%name pBExpr2 BExpr2
%name pBExpr1 BExpr1
%name pBExpr BExpr
%name pBTest BTest
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)  }
  '\''       { PT _ (TS _ 2)  }
  '('        { PT _ (TS _ 3)  }
  ')'        { PT _ (TS _ 4)  }
  ','        { PT _ (TS _ 5)  }
  ':='       { PT _ (TS _ 6)  }
  '<'        { PT _ (TS _ 7)  }
  '<='       { PT _ (TS _ 8)  }
  '=='       { PT _ (TS _ 9)  }
  '>'        { PT _ (TS _ 10) }
  '>='       { PT _ (TS _ 11) }
  'and'      { PT _ (TS _ 12) }
  'do'       { PT _ (TS _ 13) }
  'done'     { PT _ (TS _ 14) }
  'else'     { PT _ (TS _ 15) }
  'endif'    { PT _ (TS _ 16) }
  'false'    { PT _ (TS _ 17) }
  'for'      { PT _ (TS _ 18) }
  'if'       { PT _ (TS _ 19) }
  'in'       { PT _ (TS _ 20) }
  'input'    { PT _ (TS _ 21) }
  'let'      { PT _ (TS _ 22) }
  'not'      { PT _ (TS _ 23) }
  'or'       { PT _ (TS _ 24) }
  'print'    { PT _ (TS _ 25) }
  'reversed' { PT _ (TS _ 26) }
  'then'     { PT _ (TS _ 27) }
  'true'     { PT _ (TS _ 28) }
  L_Ident    { PT _ (TV $$)   }
  L_charac   { PT _ (TC $$)   }

%%

Ident :: { Parser.SimpleForProgram.Abs.Ident }
Ident  : L_Ident { Parser.SimpleForProgram.Abs.Ident $1 }

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

ListStmt :: { [Parser.SimpleForProgram.Abs.Stmt] }
ListStmt : Stmt { (:[]) $1 } | Stmt ListStmt { (:) $1 $2 }

ListIdent :: { [Parser.SimpleForProgram.Abs.Ident] }
ListIdent : Ident { (:[]) $1 } | Ident ',' ListIdent { (:) $1 $3 }

Program :: { Parser.SimpleForProgram.Abs.Program }
Program : VarStmt { Parser.SimpleForProgram.Abs.Program $1 }

VarStmt :: { Parser.SimpleForProgram.Abs.VarStmt }
VarStmt
  : 'let' ListIdent ':=' 'false' 'in' ListStmt { Parser.SimpleForProgram.Abs.VarStmt $2 $6 }
  | ListStmt { Parser.SimpleForProgram.Abs.NoVarStmt $1 }

FORInput :: { Parser.SimpleForProgram.Abs.FORInput }
FORInput
  : 'input' { Parser.SimpleForProgram.Abs.FInput }
  | 'reversed' '(' 'input' ')' { Parser.SimpleForProgram.Abs.FRevInput }

Stmt :: { Parser.SimpleForProgram.Abs.Stmt }
Stmt
  : 'for' Ident 'in' FORInput 'do' VarStmt 'done' { Parser.SimpleForProgram.Abs.SFor $2 $4 $6 }
  | Ident ':=' 'true' { Parser.SimpleForProgram.Abs.SSetTrue $1 }
  | 'if' BExpr 'then' ListStmt 'else' ListStmt 'endif' { Parser.SimpleForProgram.Abs.SIfElse $2 $4 $6 }
  | 'if' BExpr 'then' ListStmt 'endif' { Parser.SimpleForProgram.Abs.SIf $2 $4 }
  | 'print' '\'' Char '\'' { Parser.SimpleForProgram.Abs.SPrintChar $3 }
  | 'print' Ident { Parser.SimpleForProgram.Abs.SPrintLabel $2 }

BExpr2 :: { Parser.SimpleForProgram.Abs.BExpr }
BExpr2
  : 'true' { Parser.SimpleForProgram.Abs.BTrue }
  | 'false' { Parser.SimpleForProgram.Abs.BFalse }
  | Ident { Parser.SimpleForProgram.Abs.BVar $1 }
  | 'not' BExpr2 { Parser.SimpleForProgram.Abs.BNot $2 }
  | Ident BTest Ident { Parser.SimpleForProgram.Abs.BTest $1 $2 $3 }
  | '(' BExpr ')' { $2 }

BExpr1 :: { Parser.SimpleForProgram.Abs.BExpr }
BExpr1
  : BExpr2 'and' BExpr1 { Parser.SimpleForProgram.Abs.BAnd $1 $3 }
  | BExpr2 { $1 }

BExpr :: { Parser.SimpleForProgram.Abs.BExpr }
BExpr
  : BExpr1 'or' BExpr { Parser.SimpleForProgram.Abs.BOr $1 $3 }
  | BExpr1 { $1 }

BTest :: { Parser.SimpleForProgram.Abs.BTest }
BTest
  : '<=' { Parser.SimpleForProgram.Abs.TLe }
  | '<' { Parser.SimpleForProgram.Abs.TLt }
  | '>=' { Parser.SimpleForProgram.Abs.TGe }
  | '>' { Parser.SimpleForProgram.Abs.TGt }
  | '==' { Parser.SimpleForProgram.Abs.TEq }
  | '!=' { Parser.SimpleForProgram.Abs.TNeq }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

