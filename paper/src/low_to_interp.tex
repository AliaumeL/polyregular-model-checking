% LTeX: language=EN
\section{Simple For Programs and Interpretations}
\label{sec:low-level}

\todo[inline]{
    Say that we add quantifications on booleans to the logic.
}

\todo[inline]{
    Say that quantifications are bad for the solvers
}

In this section, we prove that every \kl{simple for-program} can be compiled
into a \kl{first-order interpretation} in our symbolic setting. Recall that
this is already known to be theoretically possible in the non-symbolic case
\cite{bojanczyk2018polyregular}. However, this previous proof does not provide
complexity bounds, and requires computing a normal form of the programs
\todo{cite normal form} which drastically increase the complexity of the
generated formulas.

To transform a \kl{simple for-program} into a \kl{first-order interpretation},
we use as \kl{character constants} the set of all
characters that appear in the program. Then, we will use as \kl{transduction
tags} the set of all print statements in the program (remembering their
location in the source code). The \kl(formula){arity} of a print statement will be the
number of position variables that are in the scope of the print. It is
relatively easy to compute the \kl{output function} of a print statement: if
the print statement outputs a fixed character $c$, then the \kl{output
function} will be the constant function $c$; if the print statement uses
$\mathsf{label}(i)$ for some variable $i$ in the context of the print
statement, then the \kl{output function} will be the number corresponding to
the position variable $i$ (that is, its De Bruijn index \cite{DEBRUJ72}). To
compute the \kl{ordering formula} between two print statements, we use the same
technique as described in the \kl{for loop expansion} procedure: we compare the
indices of the positions that are in the scope of the print statements, and
break ties using their ordering in the source code. Note that the \kl{ordering
formula} does not use any quantifiers.

The only non-trivial part of the transformation is to compute the \kl{domain
formula} of a print statement. This difficulty is akin to the one of the
\kl{for loop expansion} procedure in the case of a reverse loop: given a print
statement $p(i_1, \dots, i_k)$, where $i_1, \dots, i_k$ are the position
variables in the scope of the print statement, we need to check whether it can
be reached. In other words, we check that every \texttt{if} statement along the
path from the root of the program to the print statement was correctly taken.
This is done by computing the conjunction, over all the \texttt{if} statements,
of the truth values of the boolean tests that were executed. The main
difference with the \kl{for loop expansion} case is that we need to
\emph{abstractly} compute the truth values of the boolean variables used in the
tests.

To solve this issue, we will introduce the notion of \kl{program formulas},
which are \kl{first-order formulas} describing a transformation of boolean
variable's truth values. We will associate to every program statement a
corresponding \kl{program formula} (the main difficulty), which in turns allows
us to easily derive the \kl{domain formula}.



\subsection{Program Formulas}
\label{sec:program-formulas}

\AP A \intro{program formula} is a \kl{first-order formula} where every
\kl{free variable} is either: an \intro{input boolean variable}  written
$\ibvar{b}$,  an \intro{output boolean variable} written $\obvar{b}$, or an
\intro{input position variable} written $\ipvar{i}$. Given a fixed word $w \in
\mathcal{D}^*$, a \kl{program formula} $\varphi$ defines a relation between the
input variables $\ibvar{b_1}, \dots, \ibvar{b_n}$, the output variables
$\obvar{b_1}, \dots, \obvar{m}$, and the positions $\ipvar{1}, \dots,
\ipvar{k}$. We will only consider \kl{program formulas} that define
\emph{functions} for every fixed input word $w$.

\todo[inline]{Add to the semantics of the program formulas the ability
to quantify over booleans}

Our goal is to compute inductively a \kl{program formula} for every statement
of a \kl{simple for-program}. As an example, the statement \texttt{b := True}
that updates a boolean variable $b$ can be represented by the \kl{program
formula} $\Phi_{\texttt{setTrue}} := \obvar{b}$. Similarly, a print statement
can be represented by a \kl{program formula} $\Phi_{\texttt{print}} := \top$
that is always true (no boolean variables are modified). To perform our
induction step, we need to consider three constructions: the conditional
branching, the sequence and the iteration.


\paragraph{Conditional Branching.} 
Given two \kl{program formulas} $\Phi_1$ and $\Phi_2$ having 
the set of output variables,
together with a conditional formula $\varphi$, one can 
simulate the \texttt{if then else} construction 
as follows:
\begin{equation*}
    \Phi_{\texttt{if}~\varphi~\texttt{then}~\Phi_1~\texttt{else}~\Phi_2} := (\varphi \land \Phi_1) \lor (\neg \varphi \land \Phi_2) \quad .
\end{equation*}
In the case where the two \kl{program formulas} $\Phi_1$ and $\Phi_2$ have
different output variables, one can always extend $\Phi_1$ and $\Phi_2$ with
a conjunction of the
formulas $\ibvar{b} \iff \obvar{b}$ for every missing output boolean variable $b$,
that is, extending the domain of their functions by behaving as the identity.

\paragraph{Composition of Program Formulas.} The first (mild) difficulty is to
perform the sequential composition of two \kl{program formulas} in a relatively
efficient way. Let us consider two \kl{program formulas} $\Phi_1$ and $\Phi_2$,
having as \kl{input boolean variables} respectively names in
$B_1^{\mathsf{in}}$ and $B_2^{\mathsf{in}}$, and as \kl{output boolean
variables} respectively names in $B_1^{\mathsf{out}}$ and $B_2^{\mathsf{out}}$.
Let us first work in 
the simplified case where $B_2^{\mathsf{in}} =
B_1^{\mathsf{out}} = \set{b_1, \dots, b_n}$.
Then, the composition is
defined as follows:
\begin{equation*}
    \Phi_1 ; \Phi_2 :=
    \exists_{b_1 : \mathbb{B}} \cdots \exists_{b_n : \mathbb{B}}
    \quad
    \Phi_1[ \obvar{x} \mapsto x ]
    \wedge 
    \Phi_2[ \ibvar{x} \mapsto x ]
\end{equation*}

As for the case of the conditional branching, one can always extend the
\kl{program formulas} to ensure equality of input and output boolean variable
sets. For instance, if $\Phi_2$ does not depend on some boolean variable
$\ibvar{b}$, then one can replace it by $\exists_{b' : \mathbb{B}} \ibvar{b} =
b' \wedge \Phi_2$. Similarly, if $\Phi_1$ contains a variable $\obvar{b}$ that
does not appear in $\Phi_2$, then one can add $\ibvar{b} \iff \obvar{b}$ to
$\Phi_2$. Recall however that the \kl{quantifier rank} of a formula is a
parameter we are trying to control to ensure that the generated formulas are
efficiently solvable.

To circumvent this issue, we implemented a composition algorithm that only
quantifies over the boolean variables that are in the set $B_1^{\mathsf{out}}
\cap (B_2^{\mathsf{in}} \cup B_2^{\mathsf{out}})$, which is expected
to be smaller in practice. In particular, we derive the following bound
on the \kl{quantifier rank} of the composition:

\begin{equation*}
    \qrank(\Phi_1 ; \Phi_2) 
    \leq \max(\qrank(\Phi_1), \qrank(\Phi_2)) 
    +    |B_1^{\mathsf{out}} \cap (B_2^{\mathsf{in}} \cup B_2^{\mathsf{out}})|
    \quad .
\end{equation*}


\paragraph{Iteration of Program Formulas.} The second (and more problematic)
operation on \kl{program formulas} is the iteration. We will explain its
construction in the case of a \kl{program formula} $\Phi$ with a single
\kl{input position variable} $\ipvar{i}$, \kl{input boolean variables} in a set
$B^{\mathsf{in}}$ and \kl{output boolean variables} in a set
$B^{\mathsf{out}}$. Given a word $w \in \mathcal{D}^*$, evaluating a forward
loop over $i$ in the range $0$ to $|w|$ can be done by computing the following
composition: 
\begin{equation}
    \label{eq:iteration-dumb}
    \Phi[\ipvar{i} \mapsto 0] ; \Phi[\ipvar{i} \mapsto 1] ; \cdots ;
    \Phi[\ipvar{i} \mapsto |w|] \quad ,
\end{equation}
Where we replaced the \kl{input position variable}
$\ipvar{i}$ by every possible value in the range $0$ to $|w|$. The main
difficulty is to compute this composition efficiently, and indepenently of the
length of the word $w$.

To that end, remark that \kl{program formula} $\Phi$ has a finitely many output
values, and that this finite output set is \emph{ordered}: the variables can
only be set to \texttt{True} (\ref{item:mut-variables}). As a
consequence, in the composition in \cref{eq:iteration-dumb}, at
most $|B^{\mathsf{out}}|$ steps actually update the boolean variables. As a
consequence, one can \emph{accelerate} the computation of the composition by
only guessing the steps $p_1, \dots, p_{|B^{\mathsf{out}}|}$ that update the
boolean variables.
The resulting \kl{program formula} $\Phi^*$ will have the following shape, provided
that $|B^{\mathsf{out}}| = n > 2$ and $B^{\mathsf{out}} = \set{b_1, \dots, b_n}$:
\begin{align}
    \label{eq:iteration-smart}
    \Phi^* :=&~\exists_{p_1â€¯< \cdots < p_{n} : \mathbb{N}}  \\
             &~\exists_{ \seqof{b_{i,j}}[1 \leq i, j \leq n - 1] : \mathbb{B} } \\
             &~
             \Phi[\ipvar{i} \mapsto p_1, \obvar{b_i} \mapsto b_{i,1}]  \\
             &\wedge \bigwedge_{2 \leq j \leq n - 1} \Phi[\ipvar{i} \mapsto p_{j},
                                                   \ibvar{b_i} \mapsto b_{i,j-1},
                                                   \obvar{b_i} \mapsto b_{i,j}] \\
             &\wedge \Phi[\ipvar{i} \mapsto p_n, \ibvar{b_i} \mapsto b_{i,n-1}]  \\
             &\wedge 
\end{align}

The resulting \kl{program formula} $\Phi^*$ will guess these 
steps $i_1, \dots, i_k$, the truth value of the boolean variables at 
these steps and assert the following:
\begin{itemize}
    \item The steps are \emph{correct}  in the sense
        that the guessed boolean values for the output of step $j$
        are the result of applying $\Phi$ to the guessed boolean
        variables for the input of step $j$.
    \item The steps are \emph{complete} in the sense
        that between two guessed positions $i_j$ and $i_{j+1}$,
        the boolean variables are not modified.
\end{itemize}
These formulas can be written in \kl{first-order logic},

\begin{equation*}
    \qrank(\Phi^*) 
    \leq \qrank(\Phi) 
    + (\bcount(\Phi))^2
    + \bcount(\Phi)
    + 1 \quad ,
\end{equation*}
