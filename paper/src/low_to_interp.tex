% LTeX: language=EN
\section{Simple For Programs and Interpretations}
\label{sec:low-level}

In this section, we prove that every \kl{simple for-program} can be compiled
into a \kl{first-order interpretation} in our symbolic setting. Recall that
this is already known to be theoretically possible in the non-symbolic case
\cite{bojanczyk2018polyregular}. However, this previous proof does not provide
complexity bounds, and requires computing a normal form
\todo{R: cite normal form} which drastically increases the complexity of the
generated formulas.

To transform a \kl{simple for-program} into a \kl{first-order interpretation},
we use as \kl{character constants} the set of all
characters that appear in the program. For the \kl{transduction
tags} we use the set of all print statements in the program, remembering their
location in the source code. The \kl(formula){arity} of a print statement
is the number of the position variables that are in the scope of the print.
The \kl{output function} of a print statement is easy to define: if
the print statement outputs a fixed character $c$, then the \kl{output
function} returns $c$; otherwise,
if the print statement outputs $\mathsf{label}(i)$,
then the \kl{output function} returns the De Bruijn index \cite{DEBRUJ72}
of the position variable $i$. For the \kl{ordering formula} between two print statements,
we use the technique for comparing addresses of the print statements, 
described in the \kl{for loop expansion} procedure:
In order to compare of two print statement, we look 
at the locations of their shared position variables,
breaking the ties using their ordering in the source code.
Observe that such \kl{ordering formulas} do not use quantifiers.

The hardest part is the \kl{domain formula}. This difficulty is akin to the one of the
\kl{for loop expansion} procedure in the case of a reverse loop: given a print
statement $p(i_1, \dots, i_k)$, where $i_1, \dots, i_k$ are the position
variables in the scope of the print, we need to check whether it can
be reached. This amounts to taking the conjunction of the \texttt{if}-conditions, 
or their negations depending on the \texttt{if}-branch, along the path
from the root of the program to the print statement.
The only difficulty in defining this conjunction is
computing the values the boolean variables using 
first-order logic. We solve this problem, by defining
\kl{program formulas}, which are \kl{first-order formulas} 
that describe how a program statement transforms
the truth values of its boolean variables.

\subsection{Program Formulas}
\label{sec:program-formulas}

\AP A \intro{program formula} is a \kl{first-order formula} where every
\kl{free variable} is either: an \intro{input boolean variable}
$\ibvar{b}$, an \intro{output boolean variable} $\obvar{b}$, or an
\intro{input position variable} $\ipvar{i}$. In order to accommodate the
boolean variables, we introduce a new two-element sort $\mathbb{B}$. 
We handle it in the same way way as the sort $\mathbb{T}$ from \cref{sec:pullback}.

Given a fixed word $w \in \mathcal{D}^*$, a \kl{program formula}
$\varphi$ defines a relation between the input boolean variables
$\ibvar{b_1}, \dots, \ibvar{b_n}$, input position variables
$\ipvar{1}, \dots, \ipvar{k}$, and the output boolean variables
$\obvar{b_1}, \dots, \obvar{m}$. We are only interested in \kl{program formulas}
that define \emph{functions} between the input and output variables, 
for every $w$.

In this section we show how to compute \kl{program formulas} for every
program statement $s$, that describes how the statement transforms its state.
The formulas are constructed inductively on the structure of the statement.
We start with the simplest case of \texttt{b := True}, whose program 
formula is defined as $\Phi_{\texttt{setTrue}} := \obvar{b}$.
Similarly, a the program formula for a print statement is defined 
as $\Phi_{\texttt{print}} := \top$ (as it does not input or output any variables).
For the induction step, we need to consider three constructions: conditional
branching, sequencing, and iteration.

\paragraph{Conditional Branching.} 
Given two \kl{program formulas} $\Phi_1$ and $\Phi_2$
and a formula $\varphi$ that only uses input variables (position and booleans), 
we simulate the \texttt{if then else} construction in the following way:
\begin{equation*}
    \Phi_{\texttt{if}~\varphi~\texttt{then}~\Phi_1~\texttt{else}~\Phi_2} := (\varphi \land \Phi_1) \lor (\neg \varphi \land \Phi_2) \quad .
\end{equation*}
This construction only works if $\Phi_1$ and $\Phi_2$ have the same output variables. 
If this is not the case, we can to extend $\Phi_1$ and $\Phi_2$ with 
identity on the missing output variables, by adjoining them
with conjunctions of the form  $\ibvar{b} \iff \obvar{b}$
for each missing variable. 

\paragraph{Composition of Program Formulas.}
Let us consider two \kl{program formulas} $\Phi_1$ and $\Phi_2$,
and denote their input and output boolean variables as 
$B_1^{\mathsf{in}}, B_1^{\mathsf{out}}$ and $B_2^{\mathsf{in}}, B_2^{\mathsf{out}}$.
Let us start with the case where $B_2^{\mathsf{in}} = B_1^{\mathsf{out}} = \set{b_1, \dots, b_n}$.
In this case, we can compose the two program formulas in the following way:
\begin{equation*}
    \Phi_1 ; \Phi_2 :=
    \exists_{b_1 : \mathbb{B}} \cdots \exists_{b_n : \mathbb{B}}
    \quad
    \Phi_1[ \obvar{x} \mapsto x ]
    \wedge 
    \Phi_2[ \ibvar{x} \mapsto x ]
\end{equation*}
If the sets $B_1^{\mathsf{out}}$ and $B_2^{\mathsf{in}}$ are not equal,
we can deal with it by first ignoring the output variables of $\Phi_1$
that are not consumed by $\Phi_2$. Interestingly, this operation 
requires an existential quantification:
\[\Phi_1' \ := \ \exists_{b' : \mathbb{B}} \Phi_1[\obvar{b} := b'] \] 
Then, for each variable $b$ that is consumed by $\Phi_2$ but not produced by $\Phi_1$,
we add the clause $\ibvar{b} \iff \obvar{b}$ to $\Phi_1'$ obtaining $\Phi_1''$.
After this modification, we can compose $\Phi_1''$ and $\Phi_2$ as before.

This procedure requires us to quantify over input variables of $\Phi_2$, which 
increases the \kl{quantifier rank} of the resulting formula by
$|B_1^{\mathsf{out}}|$. In our implementation, we are a bit more efficient, 
and only quantify over the variables from $B_1^{\mathsf{out}}
\cap (B_2^{\mathsf{in}} \cup B_2^{\mathsf{out}})$, which, in practice, is expected
to be much smaller than $|B_2^{\mathsf{in}}|$, and we obtain the following bound
on the composition: 
\begin{equation*}
    \qrank(\Phi_1 ; \Phi_2) 
    \leq \max(\qrank(\Phi_1), \qrank(\Phi_2)) 
    +    |B_1^{\mathsf{out}} \cap (B_2^{\mathsf{in}} \cup B_2^{\mathsf{out}})|
    \quad .
\end{equation*}

\paragraph{Iteration of Program Formulas.} The most complex operation on 
program formulas is the iteration. We explain this on a representative 
case of a \kl{program formula} $\Phi$ that has a single \kl{input position variable} $\ipvar{i}$,
and whose \kl{output boolean variables} are the same as the \kl{input boolean variables}
($B^{\mathsf{in}} = B^{\mathsf{out}}$).

Given a word $w \in \mathcal{D}^*$, evaluating a forward
loop over $i$ in the range $0$ to $|w|$
can be done by computing the following composition: 
\begin{equation}
    \label{eq:iteration-dumb}
    \Phi[\ipvar{i} \mapsto 0] ; \Phi[\ipvar{i} \mapsto 1] ; \cdots ;
    \Phi[\ipvar{i} \mapsto |w|] \quad ,
\end{equation}
Where we replaced the \kl{input position variable}
$\ipvar{i}$ by every possible value in the range $0$ to $|w|$. The main
difficulty is to compute this composition independently
of the length of the word $w$, while keeping the formula, 
and its \kl{quantifier rank} small.

To that end, we observe that \kl{program formula} $\Phi$ uses a 
finite number of boolean variables, and that each of those 
variables can only be set to \texttt{True} (\ref{item:boolean-updates}).
As a consequence, in the composition in \cref{eq:iteration-dumb},
there are at most $|B^{\mathsf{out}}|$ steps that actually modify
the boolean variables. Based on this observation,
one can \emph{accelerate} the computation of the composition by
only guessing the steps $p_1, \dots, p_{|B^{\mathsf{out}}|}$ that 
actually update the boolean variables.
The resulting \kl{program formula} $\Phi^*$ will have the following shape, provided
that contains at least $3$ variables, which we denote as  $\set{b_1, \dots, b_n}$
(the cases for $n \leq 2$ are either analogous or trivial):
\begin{align}
    \Phi^* :=&~\exists_{p_0 \leq p_1 \leq \cdots \leq p_{n} \leq p_{n+1} : \mathbb{N}} 
    \label{eq:iteration-smart-pos}
    \\
             &~\exists_{\vec{b}_0, \vec{b}_1, \dots, \vec{b}_{n+1} : \mathbb{B}^n}
    \label{eq:iteration-smart-bool}
             \\
             &\bigwedge_{1 \leq j \leq n} \Phi(p_j ; \vec{b}_{j-1} ; \vec{b}_j)
    \label{eq:iteration-smart-correct}
             \\
             &\bigwedge_{1 \leq j \leq n+1}
               \forall_{p_{j-1} \leq p \leq p_j : \mathbb{N}} \;
               \Phi(p ; \vec{b}_{j-1} ; \vec{b}_{j-1}) 
    \label{eq:iteration-smart-complete}
    \\
             &\bigwedge_{1 \leq i \leq n} (\vec{b}_0)_i = \ibvar{b_i}
    \label{eq:iteration-smart-inital}
    \\
             &\bigwedge_{1 \leq i \leq n} (\vec{b}_{n+1})_i = \obvar{b_i} 
    \label{eq:iteration-smart-final}
            \quad .
\end{align}
The structure of this formula is as follows: In \cref{eq:iteration-smart-pos},
it guesses the steps $p_1, \dots, p_{n}$ that actually modify the boolean variables.
In \cref{eq:iteration-smart-bool}, it guesses the intermediate
values of the boolean variables ($\vec{b}_j$ denote vectors of $n$ boolean variables). 
In \cref{eq:iteration-smart-correct}, it asserts that the guesses where \emph{correct}, 
i.e., that the \kl{program formula} $\Phi$ applied to position $p_j$ 
and the boolean variables $\vec{b}_{j-1}$ produces the boolean variables $\vec{b}_j$.
Here $\Phi(p ; \vec{b}_{j-1} ; \vec{b}_j)$ denotes a formula $\Phi$
where the \kl{input position variable} $\ipvar{i}$ is replaced by $p$,
the \kl{input boolean variables} $\ibvar{b_i}$ are replaced by variables from $\vec{b}_{j-1}$,
and the \kl{output boolean variables} $\obvar{b_i}$ are replaced by variables from $\vec{b}_j$.
In \cref{eq:iteration-smart-complete}, it ensures that no position different than the $p_i$'s 
modifies the boolean variables. Finally, in \cref{eq:iteration-smart-inital} and \cref{eq:iteration-smart-final},
it ensures that the initial and final values of the boolean variables are correctly set to the input and output values.

The formula for the reverse loop is similar, as it suffices guess the positions $p_i$ in a decreasing order.
Our construction ensures the following bound on the quantifier rank of the resulting \kl{program formula}:
\begin{equation}
    \label{eq:iteration-smart-quantifier-rank}
    \qrank(\Phi^*) 
    \leq \qrank(\Phi) 
    + |B^{\mathsf{out}}|^2
    + |B^{\mathsf{in}}|
    + 1 \quad .
\end{equation}
In particular, this shows how the number of modified boolean variables
is a crucial parameter for the complexity of the overall procedure,
justifying the need for a careful analysis of this parameter.
