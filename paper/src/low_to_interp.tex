% LTeX: language=EN
\section{Simple For Programs and Interpretations}
\label{sec:low-level}

\todo[inline]{
    Say that we add quantifications on booleans to the logic.
}

\todo[inline]{
    Say that quantifications are bad for the solvers
}

In this section, we prove that every \kl{simple for-program} can be compiled
into a \kl{first-order interpretation} in our symbolic setting. Recall that
this is already known to be theoretically possible in the non-symbolic case
\cite{bojanczyk2018polyregular}. However, this previous proof does not provide
complexity bounds, and requires computing a normal form of the programs
\todo{cite normal form} which drastically increase the complexity of the
generated formulas.

To transform a \kl{simple for-program} into a \kl{first-order interpretation},
we use as \kl{character constants} the set of all
characters that appear in the program. Then, we will use as \kl{transduction
tags} the set of all print statements in the program (remembering their
location in the source code). The \kl(formula){arity} of a print statement will be the
number of position variables that are in the scope of the print. It is
relatively easy to compute the \kl{output function} of a print statement: if
the print statement outputs a fixed character $c$, then the \kl{output
function} will be the constant function $c$; if the print statement uses
$\mathsf{label}(i)$ for some variable $i$ in the context of the print
statement, then the \kl{output function} will be the number corresponding to
the position variable $i$ (that is, its De Bruijn index \cite{DEBRUJ72}). To
compute the \kl{ordering formula} between two print statements, we use the same
technique as described in the \kl{for loop expansion} procedure: we compare the
indices of the positions that are in the scope of the print statements, and
break ties using their ordering in the source code. Note that the \kl{ordering
formula} does not use any quantifiers.

The only non-trivial part of the transformation is to compute the \kl{domain
formula} of a print statement. This difficulty is akin to the one of the
\kl{for loop expansion} procedure in the case of a reverse loop: given a print
statement $p(i_1, \dots, i_k)$, where $i_1, \dots, i_k$ are the position
variables in the scope of the print statement, we need to check whether it can
be reached. In other words, we check that every \texttt{if} statement along the
path from the root of the program to the print statement was correctly taken.
This is done by computing the conjunction, over all the \texttt{if} statements,
of the truth values of the boolean tests that were executed. The main
difference with the \kl{for loop expansion} case is that we need to
\emph{abstractly} compute the truth values of the boolean variables used in the
tests.

To solve this issue, we will introduce the notion of \kl{program formulas},
which are \kl{first-order formulas} describing a transformation of boolean
variable's truth values. We will associate to every program statement a
corresponding \kl{program formula} (the main difficulty), which in turns allows
us to easily derive the \kl{domain formula}.



\subsection{Program Formulas}
\label{sec:program-formulas}

\AP A \intro{program formula} is a \kl{first-order formula} where every
\kl{free variable} is either: an \intro{input boolean variable}  written
$\ibvar{b}$,  an \intro{output boolean variable} written $\obvar{b}$, or an
\intro{input position variable} written $\ipvar{i}$. Given a fixed word $w \in
\mathcal{D}^*$, a \kl{program formula} $\varphi$ defines a relation between the
input variables $\ibvar{b_1}, \dots, \ibvar{b_n}$, the output variables
$\obvar{b_1}, \dots, \obvar{m}$, and the positions $\ipvar{1}, \dots,
\ipvar{k}$. We will only consider \kl{program formulas} that define
\emph{functions} for every fixed input word $w$.


Our goal is to compute inductively a \kl{program formula} for every statement
of a \kl{simple for-program}. As an example, the statement \texttt{b := True}
that updates a boolean variable $b$ can be represented by the \kl{program
formula} $\Phi_{\texttt{setTrue}} := \obvar{b}$. Similarly, a print statement
can be represented by a \kl{program formula} $\Phi_{\texttt{print}} := \top$
that is always true (no boolean variables are modified). To perform our
induction step, we need to consider three constructions: the conditional
branching, the sequence and the iteration.

In order to keep the size of the resulting formulas manageable, we will use a
similar technique as the one used to compute the \kl{pullback operation} in
\cref{sec:pullback}: we introduce
a new finite sort, the booleans. This allows us to quantify over the truth
values of boolean variables, and is central in our construction. Notice that it
does not increase the expressive power of the logic, as we can always replace
the quantification over booleans by a disjunction over its truth value.

\paragraph{Conditional Branching.} 
Given two \kl{program formulas} $\Phi_1$ and $\Phi_2$ having 
the set of output variables,
together with a conditional formula $\varphi$, one can 
simulate the \texttt{if then else} construction 
as follows:
\begin{equation*}
    \Phi_{\texttt{if}~\varphi~\texttt{then}~\Phi_1~\texttt{else}~\Phi_2} := (\varphi \land \Phi_1) \lor (\neg \varphi \land \Phi_2) \quad .
\end{equation*}
In the case where the two \kl{program formulas} $\Phi_1$ and $\Phi_2$ have
different output variables, one can always extend $\Phi_1$ and $\Phi_2$ with
a conjunction of the
formulas $\ibvar{b} \iff \obvar{b}$ for every missing output boolean variable $b$,
that is, extending the domain of their functions by behaving as the identity.

\paragraph{Composition of Program Formulas.} The first (mild) difficulty is to
perform the sequential composition of two \kl{program formulas} in a relatively
efficient way. Let us consider two \kl{program formulas} $\Phi_1$ and $\Phi_2$,
having as \kl{input boolean variables} respectively names in
$B_1^{\mathsf{in}}$ and $B_2^{\mathsf{in}}$, and as \kl{output boolean
variables} respectively names in $B_1^{\mathsf{out}}$ and $B_2^{\mathsf{out}}$.
Let us first work in 
the simplified case where $B_2^{\mathsf{in}} =
B_1^{\mathsf{out}} = \set{b_1, \dots, b_n}$.
Then, the composition is
defined as follows:
\begin{equation*}
    \Phi_1 ; \Phi_2 :=
    \exists_{b_1 : \mathbb{B}} \cdots \exists_{b_n : \mathbb{B}}
    \quad
    \Phi_1[ \obvar{x} \mapsto x ]
    \wedge 
    \Phi_2[ \ibvar{x} \mapsto x ]
\end{equation*}

As for the case of the conditional branching, one can always extend the
\kl{program formulas} to ensure equality of input and output boolean variable
sets. For instance, if $\Phi_2$ does not depend on some boolean variable
$\ibvar{b}$, then one can replace it by $\exists_{b' : \mathbb{B}} \ibvar{b} =
b' \wedge \Phi_2$. Similarly, if $\Phi_1$ contains a variable $\obvar{b}$ that
does not appear in $\Phi_2$, then one can add $\ibvar{b} \iff \obvar{b}$ to
$\Phi_2$. Recall however that the \kl{quantifier rank} of a formula is a
parameter we are trying to control to ensure that the generated formulas are
efficiently solvable.

To circumvent this issue, we implemented a composition algorithm that only
quantifies over the boolean variables that are in the set $B_1^{\mathsf{out}}
\cap (B_2^{\mathsf{in}} \cup B_2^{\mathsf{out}})$, which is expected
to be smaller in practice. In particular, we derive the following bound
on the \kl{quantifier rank} of the composition:

\begin{equation*}
    \qrank(\Phi_1 ; \Phi_2) 
    \leq \max(\qrank(\Phi_1), \qrank(\Phi_2)) 
    +    |B_1^{\mathsf{out}} \cap (B_2^{\mathsf{in}} \cup B_2^{\mathsf{out}})|
    \quad .
\end{equation*}


\paragraph{Iteration of Program Formulas.} The second (and more problematic)
operation on \kl{program formulas} is the iteration. We will explain its
construction in the case of a \kl{program formula} $\Phi$ with a single
\kl{input position variable} $\ipvar{i}$, \kl{input boolean variables} in a set
$B^{\mathsf{in}}$ and \kl{output boolean variables} in a set
$B^{\mathsf{out}}$, where $B^{\mathsf{in}} = B^{\mathsf{out}}$. Given a word $w \in \mathcal{D}^*$, evaluating a forward
loop over $i$ in the range $0$ to $|w|$ can be done by computing the following
composition: 
\begin{equation}
    \label{eq:iteration-dumb}
    \Phi[\ipvar{i} \mapsto 0] ; \Phi[\ipvar{i} \mapsto 1] ; \cdots ;
    \Phi[\ipvar{i} \mapsto |w|] \quad ,
\end{equation}
Where we replaced the \kl{input position variable}
$\ipvar{i}$ by every possible value in the range $0$ to $|w|$. The main
difficulty is to compute this composition efficiently (in terms of formula size and 
\kl{quantifier depth}), and indepenently of the
length of the word $w$.

To that end, remark that \kl{program formula} $\Phi$ has a finitely many output
values, and that this finite output set is \emph{ordered}: the variables can
only be set to \texttt{True} (\ref{item:mut-variables}). As a
consequence, in the composition in \cref{eq:iteration-dumb}, at
most $|B^{\mathsf{out}}|$ steps actually update the boolean variables. As a
consequence, one can \emph{accelerate} the computation of the composition by
only guessing the steps $p_1, \dots, p_{|B^{\mathsf{out}}|}$ that update the
boolean variables.
The resulting \kl{program formula} $\Phi^*$ will have the following shape, provided
that $|B^{\mathsf{out}}| = n > 2$ and $B^{\mathsf{out}} = \set{b_1, \dots, b_n}$:
\begin{align}
    \Phi^* :=&~\exists_{p_0 \leq p_1 \leq \cdots \leq p_{n} \leq p_{n+1} : \mathbb{N}} 
    \label{eq:iteration-smart-pos}
    \\
             &~\exists_{\vec{b}_0, \vec{b}_1, \dots, \vec{b}_{n+1} : \mathbb{B}^n}
    \label{eq:iteration-smart-bool}
             \\
             &\bigwedge_{1 \leq j \leq n} \Phi(p_j ; \vec{b}_{j-1} ; \vec{b}_j)
    \label{eq:iteration-smart-correct}
             \\
             &\bigwedge_{1 \leq j \leq n+1}
               \forall_{p_{j-1} \leq p \leq p_j : \mathbb{N}} \;
               \Phi(p ; \vec{b}_{j-1} ; \vec{b}_{j-1}) 
    \label{eq:iteration-smart-complete}
    \\
             &\bigwedge_{1 \leq i \leq n} (\vec{b}_0)_i = \ibvar{b_i}
    \label{eq:iteration-smart-inital}
    \\
             &\bigwedge_{1 \leq i \leq n} (\vec{b}_{n+1})_i = \obvar{b_i} 
    \label{eq:iteration-smart-final}
            \quad .
\end{align}
In this formula, the variables $\vec{b}_j$ are vectors of boolean variables
that represent the output of the \kl{program formula} $\Phi$ at step $j$.
To simplify notations, we wrote 
$\Phi(p ; \vec{b}_{j-1} ; \vec{b}_j)$ to denote the \kl{program formula}
$\Phi$ where the \kl{input position variable} $\ipvar{i}$ is replaced by $p$,
the \kl{input boolean variables} $\ibvar{b}$ are replaced by the vector
$\vec{b}_{j-1}$, and the \kl{output boolean variables} $\obvar{b}$ are replaced
by the vector $\vec{b}_j$.
In \cref{eq:iteration-smart-pos}, we quantify over the steps that may change
boolean variables. In \cref{eq:iteration-smart-bool}, we quantify over the
actual values of those boolean variables. Then,
we assert that the guesses were \emph{correct} in \cref{eq:iteration-smart-correct},
and ensure that no other modifications are made at different positions (i.e., the guesses were \emph{complete})
in \cref{eq:iteration-smart-complete}. Finally, we ensure that the initial
and final values of the boolean variables are correctly set in \cref{eq:iteration-smart-inital}.

The formula for the reverse loop is similar, as one only needs to quantify over
the steps in decreasing order. Notice that our construction ensures the following
bound on the quantifier rank of the resulting \kl{program formula}:
\begin{equation}
    \label{eq:iteration-smart-quantifier-rank}
    \qrank(\Phi^*) 
    \leq \qrank(\Phi) 
    + |B^{\mathsf{out}}|^2
    + |B^{\mathsf{out}}|
    + 1 \quad .
\end{equation}
In particular, this shows how the number of modified boolean variables
is a crucial parameter for the complexity of the overall procedure,
justifying the need for a careful analysis of this parameter.
