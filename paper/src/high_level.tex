% LTeX: language=EN
\section{High Level For Programs}
\label{sec:high_level}

\AP In this section, we describe a \intro{high-level language} describing
list-manipulating functions that can be seen as a subset of \texttt{Python}.
The language has been designed by discarding recursion, while loops, and only
allowing the use of generators for constructing lists. The only allowed looping
construction is then the \texttt{for} loop, which guarantees in particular the
termination of such programs. An example of such program is listed in
\cref{fig:python-example}: it takes as input a list of words containing a
stopword \texttt{stop} exactly once, and outputs a list of pairs $(w_1, w_2)$,
where $w_1$ belongs to the words before the stopword, and $w_2$ belongs to the
words after the stopword. For instance, \texttt{f(["slim", "shy", "stop",
"dog", "cat"])} outputs \texttt{[['slim', 'dog'], ['slim', 'cat'], ['shy',
'dog'], ['shy', 'cat']]}.

\begin{figure}[h]
\begin{verbatim}
def f( words : list[str] ) -> generator[list[str]]:
    seen_stop_w1 = False
    for (i, w1) in enumerate(words):
        seen_stop_w2 = False
        if w1 == "stop":
            seen_stop_w1 = True
        if not seen_stop_w1:
            for (j, w2) in reversed(enumerate(words)):
                if w2 == "stop":
                    seen_stop_w2 = True
                if not seen_stop_w2:
                    yield [w1, w2]
\end{verbatim}
\caption{An example of python program.}
\label{fig:python-example}
\end{figure}

The types allowed in the programs are either Booleans, integers, or what we
call list expressions , that are obtained by nesting strings and homogeneous
lists -- observe that this includes the elements of the alphabet itself --.

\AP We are interested in the following \intro{model checking problem}: given a
function $f \colon X \to \Bools$, decide whether there exists $x \in X$ such
that $f(x) = \btrue$.

In order to derive a \kl{model checking algorithm} for these programs, we furthermore restricted the 
language in the following ways:
\begin{enumerate}
    \item \label{item:comp-oexpr}
        We only allow equality between lists when one of them is constant.
    \item \label{item:int-cmp} 
        We severely restrict the way integers can be compared, as
        in \cref{fig:python-example}, where the integers are indices originating
        from the same input list.
    \item \label{item:no-shadowing} 
        We disallow shadowing of variable names.
    \item \label{item:func-no-bool}
        We disallow taking boolean arguments as input 
        to functions.
    \item \label{item:immut-vars} 
        Variables are immutable, except for boolean variables.
    \item \label{item:set-true}
        Boolean variables are initialized to \texttt{false} and can only
        be toggled to \texttt{true}. Which is the case
        in \cref{fig:python-example}.
\end{enumerate}
\begin{description}
    \item[For \cref{item:comp-oexpr}.]
        We could encode the post correspondence problem.
        \todo{write it explicitly}
    \item[For \cref{item:int-cmp}.] If we allow arbitrary comparisons between
        integers, then one could test equality of two input strings, from
        which results the undecidability of \kl{model checking} is undecidable.
    \item[For \cref{item:no-shadowing}.]  Shadowing could allow one to 
        fake origins of integers, hence leading to undecidable \kl{model checking}.
    \item[For functions taking no booleans]
        we could implement shadowing.
    \item[For \cref{item:immut-vars}.]
        Allowing the mutability of integer variables, then one could 
        use them as counters, from which results the undecidablity of the
        model checking.
        Allowing  the mutability of list variables 
        enables exponential output to be produced, for which the techniques 
        we build upon cannot be used.
        \todo{add an example with exponential growth}
    \item[For \cref{item:set-true}.]
        We are going to reduce the \kl{model checking problem} to 
        the satisfiability of a first order formula on finite words. This
        will enable the use of automata based tools and classical SMT solvers.
        Allowing unrestricted use of boolean variables would result in the 
        function \texttt{isOdd} to be definable, which is not expressible in 
        first order logic on words.
\end{description}

In order to formally reason about the subset of Python that we want to  model,
we introduce a syntax dedicated to our needs. Let us now discuss its main
ingredients: we explicitly distinguish between boolean, index and list
expressions, and always syntactically group indices with their origin list
(both in the for construction and in the input arguments of functions); we
distinguish between boolean variable introductions (which are always mutable),
and list variable introductions (which are always immutable). 
To reason about this, let us first introduce a typing system, which is 
quite short: 
\begin{align*}
    \tau,\sigma &::= \TBool\\
    \mid&~ \TPos[o] & o \in \oexpr \\
    \mid&~ \TOut[n] & n \in \Nat \\
    \mid&~ \tau_1 \times \dots \times \tau_k \to \TBool \\
    \mid&~ \tau_1 \times \dots \times \tau_k \to \TOut[n] 
\end{align*}

Let us immediately provide a semantics for these types, by stating that
$\semT{\TBool} = \Bools$, $\semT{\TPos} = \Nat$ and $\semT{\TOut} = \bigcup_{n
\in \Nat} {{{(\Sigma)}^*}^{\dots}}^{*}$. Indeed, the extra type information in
the positions, namely an origin list expression, is discarded at runtime.

\textbf{TODO: this is a convincing subset of python}

Most of the restrictions listed above are straightforward to check, except for
the origin restriction on the integer variables, which we now will refer to as
indices (since they are always indexing a position of a list). To ensure that
comparisons are well-behaved, we developed a type system that is described 
in figure \todo{write the type system}.
The key idea is that every index variable is created in a for loop statement,
and can therefore be associated to an expression of a list type. Beware that 
we allow comparisons between indices obtained when iterating forward and backward 
the same element.


\textbf{todo write examples of bad programs}

\subsection{Syntax}


\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\bBinOp := &~ \land ~|~ \lor ~|~ \Rightarrow ~|~ \Leftrightarrow \\
        \intro*\pCmpOp := &~ = ~|~ \neq ~|~ < ~|~ \leq ~|~ > ~|~ \geq \\
        \intro*\bexpr :=&~ \intro*\btrue ~|~ \intro*\bfalse ~|~ \bnot{\bexpr} \\
               |&~ \bbin{\bexpr}{\bBinOp}{\bexpr}   \\
               |&~ \bcomp{i}{\pCmpOp}{j} & i,j \in \PVars \\
               |&~ \bapp{f}{\bexpr} & f \in \FunVars \\
               |&~ \bliteq{\cexpr}{\oexpr}
    \end{align*}
    \caption{Boolean expressions.}
    \label{fig:bool-expr}
\end{figure}


\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\cexpr :=&~ \mathsf{char} \; c & c \in \Sigma \\
               |&~ \mathsf{list}(\cexpr_1, \ldots, \cexpr_n)
    \end{align*}
    \caption{Constant expressions.}
    \label{fig:const-expr}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\oexpr :=&~ x & x \in \OVars \\
               |&~ \cexpr \\
               |&~ \olist{\oexpr_1, \dots,  \oexpr_n}  \\
               |&~ f(\aexpr_1, \dots, \aexpr_n) & f \in \FunVars \\
    \end{align*}
    \caption{Output expressions.}
    \label{fig:out-expr}
\end{figure}

\begin{figure}[h]
    \centering
    \AP
    \begin{align*}
        \intro*\hlstmt :=&~ 
                   \intro*\hlif{\bexpr}{\hlstmt}{\hlstmt} \\
               |&~ \intro*\hlyield{\oexpr} \\
               |&~ \intro*\hlreturn{\oexpr} \\
               |&~ \intro*\hlletoutput{x}{\oexpr}{\hlstmt} & x \in \OVars \\
               |&~ \intro*\hlletboolean{x}{\hlstmt} & x \in \BVars \\
               |&~ \intro*\hlsettrue{x} & x \in \BVars \\
               |&~ \intro*\hlfor{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \intro*\hlforRev{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \intro*\hlseq{\hlstmt}{\hlstmt}
    \end{align*}
    \caption{Control statements.}
    \label{fig:high-level-stmt}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \aexpr :=&~ (\oexpr, p_1, \dots, p_n) & \forall 1 \leq i \leq n, p_i \in \PVars \\
        \hlfun :=&~ \hlfundef{f}{\aexpr_1, \dots, \aexpr_n}{\hlstmt} & f \in \FunVars \\
        \hlprogram :=&~ ([\hlfun_1, \dots, \hlfun_n], f) & f \in \FunVars \\
    \end{align*}
    \caption{High Level For Programs.}
    \label{fig:high-level-program}
\end{figure}


\subsection{Semantics}

\begin{figure}[h]
    \centering
    \begin{align*}
        \semB{ \cdot }{\rho}               \colon&~ \bexpr \to \Bools \\
        \semB{\btrue}{\rho}               =&~ \top \\
        \semB{\bfalse}{\rho}              =&~ \bot \\
        \semB{b}{\rho}                    =&~ \rho(b) & b \in \BVars \\
        \semB{\bnot{b}}{\rho}             =&~ \neg \semB{b}{\rho} \\
        \semB{\bbin{b_1}{op}{b_2}}{\rho}  =&~ \semB{b_1}{\rho} \mathbin{op} \semB{b_2}{\rho} \\
        \semB{\bcomp{i}{op}{j}}{\rho}     =&~ \rho(i) \mathbin{op} \rho(j) \\
        \semB{\bapp{f}{b}}{\rho}          =&~ \semF{f}{\rho}(\semB{b}{\rho}) \\
        \semB{\bliteq{c}{o}}{\rho}        =&~ \semC{c}{\rho} = \semO{o}{\rho}
    \end{align*}
    \caption{Semantics of boolean expressions}.
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semC{ \cdot }                  \colon&~ \cexpr \to \OutputType \\
        \semC{\cchar{c}}                =&~ c \\
        \semC{\clist{c_1, \ldots, c_n}} =&~ [c_1, \ldots, c_n]
    \end{align*}
    \caption{Semantics of constant expressions.}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semO{ \cdot }{\rho}       \colon&~ \oexpr \to \OutputType \\
        \semO{x}{\rho}                  =&~ \rho(x) & x \in \OVars \\
        \semO{\cexpr}{\rho}             =&~ \semC{\cexpr} \\
        \semO{\olist{o_1, \ldots, o_n}}{\rho} =&~ [\semO{o_1}{\rho}, \ldots, \semO{o_n}{\rho}] \\
        \semO{f(\aexpr_1, \dots, \aexpr_n)}{\rho} =&~ \semF{f}{\rho}(\semO{\aexpr_1}{\rho}, \dots, \semO{\aexpr_n}{\rho})
    \end{align*}
    \caption{Semantics of output expressions.}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semC{\cdot}{\rho} \colon&~ \hlstmt \to \rho \to \rho \\
    \end{align*}
    \caption{Semantics of control statements.}
    \label{fig:semantics-control}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semF{\cdot}{\rho} \colon&~ \hlfun \to \rho \to \rho \\
        \semF{\hlfundef{f}{\aexpr_1, \dots, \aexpr_n}{\hlstmt}}{\rho} =&~ \lambda x_1, \dots, x_n. \semC{\hlstmt}{\rho[x_1 \mapsto \semO{\aexpr_1}{\rho}, \dots, x_n \mapsto \semO{\aexpr_n}{\rho}]}
    \end{align*}
    \caption{Semantics of functions.}
    \label{fig:semantics-functions}
\end{figure}

\begin{figure}
\end{figure}


% Basic typing judgments
\begin{prooftree}
\AxiomC{}
\RightLabel{(T-True)}
\UnaryInfC{$\Gamma \vdash \btrue : \TBool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(T-False)}
\UnaryInfC{$\Gamma \vdash \bfalse : \TBool$}
\end{prooftree}

% Boolean expressions
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\RightLabel{(T-Not)}
\UnaryInfC{$\Gamma \vdash \bnot{e} : \TBool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1 : \TBool$}
\AxiomC{$\Gamma \vdash e_2 : \TBool$}
\RightLabel{(T-BBin)}
\BinaryInfC{$\Gamma \vdash \bbin{e_1}{\odot}{e_2} : \TBool$}
\end{prooftree}

% Position comparisons
\begin{prooftree}
\AxiomC{$\Gamma(i) = \TPos[o_i]$}
\AxiomC{$\Gamma(j) = \TPos[o_j]$}
\AxiomC{$o_i = o_j$}
\RightLabel{(T-PComp)}
\TrinaryInfC{$\Gamma \vdash \bcomp{i}{\odot}{j} : \TBool$}
\end{prooftree}

% Function application in boolean expressions
\begin{prooftree}
\AxiomC{$\Delta(f) = (\tau_1,\ldots,\tau_n) \to \TBool$}
\AxiomC{$\Gamma \vdash e : \tau_1$}
\RightLabel{(T-BApp)}
\BinaryInfC{$\Gamma \vdash \bapp{f}{e} : \TBool$}
\end{prooftree}

% Output expressions
\begin{prooftree}
\AxiomC{$\Gamma(x) = \TOut[n]$}
\RightLabel{(T-OVar)}
\UnaryInfC{$\Gamma \vdash x : \TOut[n]$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash e_i : \TOut[n]$ for all $i$}
\RightLabel{(T-OList)}
\UnaryInfC{$\Gamma \vdash \olist{e_1,\ldots,e_n} : \TOut[n+1]$}
\end{prooftree}

% Statements
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\AxiomC{$\Gamma \vdash s_1 : \tau$}
\AxiomC{$\Gamma \vdash s_2 : \tau$}
\RightLabel{(T-If)}
\TrinaryInfC{$\Gamma \vdash \hlif{e}{s_1}{s_2} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\RightLabel{(T-Yield)}
\UnaryInfC{$\Gamma \vdash \hlyield{e} : \TOut[n+1]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\RightLabel{(T-Return)}
\UnaryInfC{$\Gamma \vdash \hlreturn{e} : \TOut[n]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\RightLabel{(T-Return)}
\UnaryInfC{$\Gamma \vdash \hlreturn{e} : \TBool$}
\end{prooftree}

% Let bindings
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\AxiomC{$\Gamma, x:\TOut[n] \vdash s : \tau$}
\RightLabel{(T-LetOut)}
\BinaryInfC{$\Gamma \vdash \hlletoutput{x}{e}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma, x:\TBool \vdash s : \tau$}
\RightLabel{(T-LetBool)}
\UnaryInfC{$\Gamma \vdash \hlletboolean{x}{s} : \tau$}
\end{prooftree}

% For loops
\begin{prooftree}
\AxiomC{$\Gamma \vdash o : \TOut[n]$}
\AxiomC{$\Gamma, i:\TPos[o], x:\TOut[n] \vdash s : \tau$}
\AxiomC{$n > 0$}
\RightLabel{(T-For)}
\TrinaryInfC{$\Gamma \vdash \hlfor{(i,x)}{o}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash o : \TOut[n]$}
\AxiomC{$\Gamma, i:\TPos[o], x:\TOut \vdash s : \tau$}
\AxiomC{$n > 0$}
\RightLabel{(T-ForRev)}
\TrinaryInfC{$\Gamma \vdash \hlforRev{(i,x)}{o}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(T-SetTrue)}
\UnaryInfC{$\Gamma \vdash \hlsettrue{x} : \tau$}
\end{prooftree}

% Sequence
\begin{prooftree}
\AxiomC{$\Gamma \vdash s_1 : \tau$}
\AxiomC{$\Gamma \vdash s_2 : \tau$}
\RightLabel{(T-Seq)}
\BinaryInfC{$\Gamma \vdash \hlseq{s_1}{s_2} : \tau$}
\end{prooftree}

% Function definition
\begin{prooftree}
\AxiomC{$\Gamma \vdash \aexpr_i : \tau_i$ for all $i$}
\AxiomC{$\Gamma \vdash s : \tau$}
\RightLabel{(T-Fun)}
\BinaryInfC{$\Delta \vdash \hlfundef{f}{(\aexpr_1,\ldots,\aexpr_n)}{s} : (\tau_1,\ldots,\tau_n) \to \tau$}
\end{prooftree}

% Program
\begin{prooftree}
\AxiomC{$\Delta \vdash \hlfun_i : \tau_i$ for all $i$}
\AxiomC{$f \in \FunVars$}
\RightLabel{(T-Prog)}
\BinaryInfC{$\vdash ([\hlfun_1,\ldots,\hlfun_n], f) : \tau_f$}
\end{prooftree}
