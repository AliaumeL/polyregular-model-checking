% LTeX: language=EN
\section{High Level For Programs}
\label{sec:high_level}

\AP In this section, we introduce our \intro{high-level language} for
describing list-manipulating functions which can be seen as a subset of
\texttt{Python}. Our goal is to reason algorithmically about the programs
written in this language, so it needs to be highly restricted. To illustrate
those restrictions, let us present a comprehensive example written in a subset
of \texttt{Python}. 

\begin{figure}[h]
    \centering
    \input{figs/python-nested.tex}
    \caption{A small Python program that
        outputs all subwords of a given word containing \texttt{ab}
        as a scattered subword}.
    \label{fig:python-example-nested}
\end{figure}

For the sake of readability, we implicitly coerce generators (created using the
\texttt{yield} keyword) to lists. Our programs will only deal with three kinds
of values: \intro{(nested) words} --- i.e. characters, words, lists of words,
lists of lists of words, etc. ---, integers, and booleans. In order to ensure
decidable \kl{model checking}, we also will enforce the following conditions,
which are satisfied in our example:
\begin{description}
    \item[Loop Constructions.]
        We only allow \texttt{for} loops iterating forward
        or backward over a list, as in 
        \circleref{6}{code-enumerate} and \circleref{7}{code-enumerate-rev}.
        In particular, \texttt{while} loops and recursive functions 
        are forbidden, which guarantees termination of our programs.

    \item [Mutable Variables.] The only mutable variables are booleans. The
        values of integer variables are introduced by the \texttt{for} loop
        as in \circleref{6}{code-enumerate},
        and their values are fixed during each iteration. Mutable integer
        variables could serve as unrestricted counters, resulting in
        undecidable \kl{model checking}. Similarly, we prohibit mutable list
        variables, as their lengths could be used as counters.
        However, we still allow the use of immutable
        list variables, as in \circleref{8}{code-immutable-variable}.

    \item [Restricted equality checks for nested words.] 
        We disallow equality
        checks between two \kl{nested words}, 
        unless one of them is a constant expression.
        This is what happens in point \circleref{4}{code-string-comp}
        of our \cref{fig:python-example-nested}.
        Without this restriction, \kl{model checking} would be undecidable
        (\cref{lem:umc-equality-nested-words}).
        
    \item [Integer Comparisons.] 
        The only allowed operations on integers
        are usual comparisons operators (equality, inequalities).
        However, we only
        allow comparisons between integers that are indices of the
        same list.
        Every integer is associated to a list expression.
        For instance, in points \circleref{6}{code-enumerate} and
        \circleref{7}{code-enumerate-rev} of our example, the variables
        $i$ and $j$ are associated to the same list variable \texttt{word}.
        Similarly, in for the comparison 
        of point \circleref{1}{code-comparisons} to be valid,
        the variables $k$,$i$, and $j$ should all be associated to the same 
        list variable $l$.

        To ensure this compatibility, we designed the following type system,
        containing Booleans, \kl{nested words} of a given depth
        (characters are of depth $0$), and integers associated to a list
        expression (the set of which is denoted by $\oexpr$, and will
        be defined later on):
        \begin{align*}
            \tau ::=~ \TBool
            ~\mid~ \TPos[o] 
            ~\mid~ \TOut[n] 
            \quad 
            n \in \Nat, \,
            o \in \oexpr
            \quad .
        \end{align*}
        These types can be inferred from the context,
        except in the case of function arguments, in which case
        we explicitly specify to which list argument integer variables
        are associated.

        Without this restriction, the equality predicate can be 
        defined between two lists, leading to an undecidable
        \kl{model checking problem}.


    \item [Variable Shadowing.] 
        We disallow shadowing of variable names, as it could
          be used to forge the origin of integers, leading to unrestricted comparisons.
          \begin{verbatim}
            \input{programs/eq_from_idxc_shadowing.py}
          \end{verbatim} 

    \item [Boolean Arguments.] 
        Allowing functions to take boolean arguments
        would allow to forge the origin of integers,
        by considering the function \texttt{switch(l1, l2, b)} which
        returns either \texttt{l1} or \texttt{l2} 
        depending on the value of \texttt{b}.
        \begin{verbatim}
            \input{programs/eq_from_idxc_shadowing.py} 
        \end{verbatim} 

    \item [Boolean Updates.] 
        Boolean variables are initialized to \texttt{false}
        as in \circleref{3}{code-mut-bool}, and
        once they are set to \texttt{true} as in 
        \circleref{5}{code-set-true},
        they cannot be reset to \texttt{false}. 
        We depart here from the semantics of Python by
        considering lexical scoping of variables; in
        particular a variable declared in a loop is not
        accessible outside this loop.

        This restriction allows us to reduce the \kl{model checking problem} to
        the satisfiability of a \kl{first order formula} on finite words.
        This problem is not only decidable but also solvable by well-engineered
        existing tools, such as automata-based solvers (e.g., MONA) and
        classical SMT solvers (e.g., Alt-Ergo, Z3, CVC5). Without this
        restriction, the problem would require the use the MSO logic on words
        which is still decidable but not supported by the SMT solvers. 

\end{description}


\paragraph{Syntax.}
\begin{align*}
    \mathsf{arg} ::=&~ (\TOut[n],k) & k \in \Nat \\
    \mathsf{fun} ::=&~ 
           \mathsf{arg}_1 \times \cdots \times \mathsf{arg}_k \to \TBool \\
    \mid&~ \mathsf{arg}_1 \times \cdots \times \mathsf{arg}_k \to \TOut[n] 
\end{align*}

\AP For instance, the function \texttt{getBetweenIndicesBeforeStop(l, i, j)}
that returns all elements of the list $l$ between the indices $i$ and $j$
before the first occurrence of the element \texttt{"stop"} has type
$(\TOut[2],2) \to \TOut[2]$, that is, we are given an input list $l$ together
with two pointers to indices of this particular list. We provide in
\cref{fig:python-example-indices}
the
code of this function, that illustrates the allowed constructions in our
language and highlights the typing constraints that we enforce.


Now, we can define the syntax of our high-level language.
Let us start with the non-surprising ingredients, namely Boolean expressions
($\bexpr$, defined in \cref{fig:bool-expr}),
constant expressions and list expressions ($\cexpr$ and $\oexpr$, defined in
\cref{fig:const-expr} and \cref{fig:out-expr}
respectively). Now, for the control flow
constructs, let us highlight that we distinguish two types of for loops: one
that iterates forward over a list and one that iterates backward. Beware that
for the backward iteration, the intended semantics is the one of the Python
fragment \texttt{for (i,x) in reversed(enumerate(l))}, and \textbf{not} the
Python fragment \texttt{for (i,x) in enumerate(reversed(l))}, as the latter
would allow to define the equality predicate between two lists, leading to an
undecidable \kl{model checking problem}. The syntax of control statements is
described in \cref{fig:high-level-stmt}, and the
syntax of \kl{high-level programs} is described in
\cref{fig:high-level-program}.


\paragraph{Semantics.} If the semantics of the boolean expressions and list
expressions are classical, let us talk about statements. As already explained,
the semantics of a backward loop iteration over a list $l$ is to iterate over
the reverse of the enumeration of $l$. Furthermore, we took the decision to
allow combining statements $\hlyield{x}$ and $\hlreturn{y}$ in the same function,
with the semantics of combining their output. For instance, the program
$\hlseq{(\hlforRev{(i,x)}{l}{\hlyield{x}})}{\hlreturn{l}}$ outputs the reverse of
$l$ and then $l$ itself.
Other than this technical choice, the semantics follows the one of
our subset of Python.

Most of the restrictions listed above are straightforward to check, except for
the origin restriction on the integer variables, which we now will refer to as
indices (since they are always indexing a position of a list). To ensure that
comparisons are well-behaved, we developed a type system that is described 
in figure \todo{write the type system}.
The key idea is that every index variable is created in a for loop statement,
and can therefore be associated to an expression of a list type. Beware that 
we allow comparisons between indices obtained when iterating forward and backward 
the same element.


\textbf{todo write examples of bad programs}

\subsection{Syntax}


\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\bBinOp := &~ \land ~|~ \lor ~|~ \Rightarrow ~|~ \Leftrightarrow \\
        \intro*\pCmpOp := &~ = ~|~ \neq ~|~ < ~|~ \leq ~|~ > ~|~ \geq \\
        \intro*\bexpr :=&~ \intro*\btrue ~|~ \intro*\bfalse ~|~ \bnot{\bexpr} \\
               |&~ \bbin{\bexpr}{\bBinOp}{\bexpr}   \\
               |&~ \bcomp{i}{\pCmpOp}{j} & i,j \in \PVars \\
               |&~ \bapp{f}{\bexpr} & f \in \FunVars \\
               |&~ \bliteq{\cexpr}{\oexpr}
    \end{align*}
    \caption{Boolean expressions.}
    \label{fig:bool-expr}
\end{figure}


\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\cexpr :=&~ \mathsf{char} \; c & c \in \Sigma \\
               |&~ \mathsf{list}(\cexpr_1, \ldots, \cexpr_n)
    \end{align*}
    \caption{Constant expressions.}
    \label{fig:const-expr}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\oexpr :=&~ x & x \in \OVars \\
               |&~ \cexpr \\
               |&~ \olist{\oexpr_1, \dots,  \oexpr_n}  \\
               |&~ f(\aexpr_1, \dots, \aexpr_n) & f \in \FunVars \\
    \end{align*}
    \caption{Output expressions.}
    \label{fig:out-expr}
\end{figure}

\begin{figure}[h]
    \centering
    \AP
    \begin{align*}
        \intro*\hlstmt :=&~ 
                   \intro*\hlif{\bexpr}{\hlstmt}{\hlstmt} \\
               |&~ \intro*\hlyield{\oexpr} \\
               |&~ \intro*\hlreturn{\oexpr} \\
               |&~ \intro*\hlletoutput{x}{\oexpr}{\hlstmt} & x \in \OVars \\
               |&~ \intro*\hlletboolean{x}{\hlstmt} & x \in \BVars \\
               |&~ \intro*\hlsettrue{x} & x \in \BVars \\
               |&~ \intro*\hlfor{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \intro*\hlforRev{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \intro*\hlseq{\hlstmt}{\hlstmt}
    \end{align*}
    \caption{Control statements.}
    \label{fig:high-level-stmt}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \aexpr :=&~ (\oexpr, p_1, \dots, p_n) & \forall 1 \leq i \leq n, p_i \in \PVars \\
        \hlfun :=&~ \hlfundef{f}{\aexpr_1, \dots, \aexpr_n}{\hlstmt} & f \in \FunVars \\
        \hlprogram :=&~ ([\hlfun_1, \dots, \hlfun_n], f) & f \in \FunVars \\
    \end{align*}
    \caption{High Level For Programs.}
    \label{fig:high-level-program}
\end{figure}


\subsection{Semantics}

\begin{figure}[h]
    \centering
    \begin{align*}
        \semB{ \cdot }{\rho}               \colon&~ \bexpr \to \Bools \\
        \semB{\btrue}{\rho}               =&~ \top \\
        \semB{\bfalse}{\rho}              =&~ \bot \\
        \semB{b}{\rho}                    =&~ \rho(b) & b \in \BVars \\
        \semB{\bnot{b}}{\rho}             =&~ \neg \semB{b}{\rho} \\
        \semB{\bbin{b_1}{op}{b_2}}{\rho}  =&~ \semB{b_1}{\rho} \mathbin{op} \semB{b_2}{\rho} \\
        \semB{\bcomp{i}{op}{j}}{\rho}     =&~ \rho(i) \mathbin{op} \rho(j) \\
        \semB{\bapp{f}{b}}{\rho}          =&~ \semF{f}{\rho}(\semB{b}{\rho}) \\
        \semB{\bliteq{c}{o}}{\rho}        =&~ \semC{c}{\rho} = \semO{o}{\rho}
    \end{align*}
    \caption{Semantics of boolean expressions}.
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semC{ \cdot }                  \colon&~ \cexpr \to \OutputType \\
        \semC{\cchar{c}}                =&~ c \\
        \semC{\clist{c_1, \ldots, c_n}} =&~ [c_1, \ldots, c_n]
    \end{align*}
    \caption{Semantics of constant expressions.}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semO{ \cdot }{\rho}       \colon&~ \oexpr \to \OutputType \\
        \semO{x}{\rho}                  =&~ \rho(x) & x \in \OVars \\
        \semO{\cexpr}{\rho}             =&~ \semC{\cexpr} \\
        \semO{\olist{o_1, \ldots, o_n}}{\rho} =&~ [\semO{o_1}{\rho}, \ldots, \semO{o_n}{\rho}] \\
        \semO{f(\aexpr_1, \dots, \aexpr_n)}{\rho} =&~ \semF{f}{\rho}(\semO{\aexpr_1}{\rho}, \dots, \semO{\aexpr_n}{\rho})
    \end{align*}
    \caption{Semantics of output expressions.}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semC{\cdot}{\rho} \colon&~ \hlstmt \to \rho \to \rho \\
    \end{align*}
    \caption{Semantics of control statements.}
    \label{fig:semantics-control}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semF{\cdot}{\rho} \colon&~ \hlfun \to \rho \to \rho \\
        \semF{\hlfundef{f}{\aexpr_1, \dots, \aexpr_n}{\hlstmt}}{\rho} =&~ \lambda x_1, \dots, x_n. \semC{\hlstmt}{\rho[x_1 \mapsto \semO{\aexpr_1}{\rho}, \dots, x_n \mapsto \semO{\aexpr_n}{\rho}]}
    \end{align*}
    \caption{Semantics of functions.}
    \label{fig:semantics-functions}
\end{figure}

\begin{figure}
\end{figure}


% Basic typing judgments
\begin{prooftree}
\AxiomC{}
\RightLabel{(T-True)}
\UnaryInfC{$\Gamma \vdash \btrue : \TBool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(T-False)}
\UnaryInfC{$\Gamma \vdash \bfalse : \TBool$}
\end{prooftree}

% Boolean expressions
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\RightLabel{(T-Not)}
\UnaryInfC{$\Gamma \vdash \bnot{e} : \TBool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1 : \TBool$}
\AxiomC{$\Gamma \vdash e_2 : \TBool$}
\RightLabel{(T-BBin)}
\BinaryInfC{$\Gamma \vdash \bbin{e_1}{\odot}{e_2} : \TBool$}
\end{prooftree}

% Position comparisons
\begin{prooftree}
\AxiomC{$\Gamma(i) = \TPos[o_i]$}
\AxiomC{$\Gamma(j) = \TPos[o_j]$}
\AxiomC{$o_i = o_j$}
\RightLabel{(T-PComp)}
\TrinaryInfC{$\Gamma \vdash \bcomp{i}{\odot}{j} : \TBool$}
\end{prooftree}

% Function application in boolean expressions
\begin{prooftree}
\AxiomC{$\Delta(f) = (\tau_1,\ldots,\tau_n) \to \TBool$}
\AxiomC{$\Gamma \vdash e : \tau_1$}
\RightLabel{(T-BApp)}
\BinaryInfC{$\Gamma \vdash \bapp{f}{e} : \TBool$}
\end{prooftree}

% Output expressions
\begin{prooftree}
\AxiomC{$\Gamma(x) = \TOut[n]$}
\RightLabel{(T-OVar)}
\UnaryInfC{$\Gamma \vdash x : \TOut[n]$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash e_i : \TOut[n]$ for all $i$}
\RightLabel{(T-OList)}
\UnaryInfC{$\Gamma \vdash \olist{e_1,\ldots,e_n} : \TOut[n+1]$}
\end{prooftree}

% Statements
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\AxiomC{$\Gamma \vdash s_1 : \tau$}
\AxiomC{$\Gamma \vdash s_2 : \tau$}
\RightLabel{(T-If)}
\TrinaryInfC{$\Gamma \vdash \hlif{e}{s_1}{s_2} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\RightLabel{(T-Yield)}
\UnaryInfC{$\Gamma \vdash \hlyield{e} : \TOut[n+1]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\RightLabel{(T-Return)}
\UnaryInfC{$\Gamma \vdash \hlreturn{e} : \TOut[n]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\RightLabel{(T-Return)}
\UnaryInfC{$\Gamma \vdash \hlreturn{e} : \TBool$}
\end{prooftree}

% Let bindings
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\AxiomC{$\Gamma, x:\TOut[n] \vdash s : \tau$}
\RightLabel{(T-LetOut)}
\BinaryInfC{$\Gamma \vdash \hlletoutput{x}{e}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma, x:\TBool \vdash s : \tau$}
\RightLabel{(T-LetBool)}
\UnaryInfC{$\Gamma \vdash \hlletboolean{x}{s} : \tau$}
\end{prooftree}

% For loops
\begin{prooftree}
\AxiomC{$\Gamma \vdash o : \TOut[n]$}
\AxiomC{$\Gamma, i:\TPos[o], x:\TOut[n] \vdash s : \tau$}
\AxiomC{$n > 0$}
\RightLabel{(T-For)}
\TrinaryInfC{$\Gamma \vdash \hlfor{(i,x)}{o}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash o : \TOut[n]$}
\AxiomC{$\Gamma, i:\TPos[o], x:\TOut \vdash s : \tau$}
\AxiomC{$n > 0$}
\RightLabel{(T-ForRev)}
\TrinaryInfC{$\Gamma \vdash \hlforRev{(i,x)}{o}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(T-SetTrue)}
\UnaryInfC{$\Gamma \vdash \hlsettrue{x} : \tau$}
\end{prooftree}

% Sequence
\begin{prooftree}
\AxiomC{$\Gamma \vdash s_1 : \tau$}
\AxiomC{$\Gamma \vdash s_2 : \tau$}
\RightLabel{(T-Seq)}
\BinaryInfC{$\Gamma \vdash \hlseq{s_1}{s_2} : \tau$}
\end{prooftree}

% Function definition
\begin{prooftree}
\AxiomC{$\Gamma \vdash \aexpr_i : \tau_i$ for all $i$}
\AxiomC{$\Gamma \vdash s : \tau$}
\RightLabel{(T-Fun)}
\BinaryInfC{$\Delta \vdash \hlfundef{f}{(\aexpr_1,\ldots,\aexpr_n)}{s} : (\tau_1,\ldots,\tau_n) \to \tau$}
\end{prooftree}

% Program
\begin{prooftree}
\AxiomC{$\Delta \vdash \hlfun_i : \tau_i$ for all $i$}
\AxiomC{$f \in \FunVars$}
\RightLabel{(T-Prog)}
\BinaryInfC{$\vdash ([\hlfun_1,\ldots,\hlfun_n], f) : \tau_f$}
\end{prooftree}
