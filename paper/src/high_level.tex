% LTeX: language=EN
\section{High Level For Programs}
\label{sec:high_level}

\AP In this section, we describe our \intro{high-level language} for describing
list-manipulating functions which can be seen as a subset of \texttt{Python}.
Our goal is to reason algorithmically about the programs written in this language,
so it needs to be highly restricted. In particular, we disallow recursion and
while loops, leaving the \texttt{for} loop as the only allowed looping
%and the only allowed way of constructing lists is through generators.
construction, which guarantees the termination of such programs.
An example of such program is listed in \cref{fig:python-example}: 
Before we delve into the details of the language, let us present 
an example in listing \ref{fig:python-example}. The program inputs
a list of words containing the word \texttt{stop} exactly once,
and outputs a list of pairs $(w_1, w_2)$, where $w_1$ and $w_2$ are words
appearing respectively before and after the word \texttt{stop}. For example:
\[
\begin{tabular}{c}
    \texttt{pairs(["slim", "shy", "stop", "dog", "cat"])} \\
    \texttt{=} \\
    \texttt{[['slim', 'cat'], ['slim', 'dog'], ['shy', 'cat'], ['shy', 'dog']]}
\end{tabular}
\] 
\begin{figure}[h]
\begin{verbatim}
def pairs( words ):
    seen_stop_w1 = False
    for (i, w1) in enumerate(words):
        seen_stop_w2 = False
        if w1 == "stop":
            seen_stop_w1 = True
        if not seen_stop_w1:
            for (j, w2) in reversed(enumerate(words)):
                if w2 == "stop":
                    seen_stop_w2 = True
                if not seen_stop_w2:
                    yield [w1, w2]
\end{verbatim}
\caption{An example of python program.}
\label{fig:python-example}
\end{figure}

% The types allowed in the programs are either Booleans, integers, or what we
% call list expressions , that are obtained by nesting strings and homogeneous
% lists -- observe that this includes the elements of the alphabet itself --.

\AP The crucial property of \kl{high-level language} it hat it has decidable 
\intro{model checking problem}: given a function $f \colon X \to \Bools$,
we can decide whether there exists $x \in X$ such that $f(x) = \btrue$.
In order to achieve this property, we restrict the language in the followg ways:
\begin{description}
    \item [No while loops and recursion.] As mentioned above, we only allow
        the \texttt{for} as the looping construction. This guaranteed the 
        termination of our program.
    \item [Restricted type system.] The only allowed types are booleans, integers, 
        and \intro{nested words types}, which consists of \mathtt{Char}, 
        \mathtt{List[Char]}, \mathtt{List[List[Char]]}, and so on. 
        % Point to a grammar entry? Describe more formally?
    \item [Restricted equality checks for nested words.] We disallow equality
        checks between two nested words, unless one of them is a constant expression.
        As the following example shows, this restriction is necessary to ensure
        decidable model checking:
        \begin{example}
            For every instance of the Post Correspondence Problem (PCP), we can 
            construct a function \texttt{f(x : list[list[Char]]) : Bool}
            in the \kl{high-level language} with unrestricted equality checks, such 
            that $f(x) = \btrue$ if and only if $x$ encodes a solution to the PCP instance.
            For example the PCP instance $\{ (ab, a), (b, aa), (ba, b) \}$ can be encoded 
            as the following function:
            \begin{verbatim}
                \input{programs/pcp_instance.py}
            \end{verbatim}
        \end{example}
        Note that this restriction also includes \texttt{Char}. The reason for this 
        more technical and explained in \ref{sec:pullback}. 
    \item [Restricted integer comparisons.] The only allowed operations or integers
          is the equality check ($\mathtt{=}, {!=}$) and comparisons (such as $\mathtt{<}$ or $\mathtt{>=}$).
          However, we allow comparisons between integers that are indices of the same list (observe
          that the only way to create an integer is through the \texttt{for} loop). Without this restriction, 
          we would be able to encode the equality of two string over the alphabet $\{a, b\}$ which would 
          enable us to encode the Post Correspondence Problem.
          \begin{verbatim}
            \input{programs/eq_from_idxc.py}
          \end{verbatim}
    \item [Immutable variables.] The only mutable variables are booleans.
          The values of integer variables are introduced by the \texttt{for} loop,
          and their values are fixed during each iteration. Mutable integer variables
          could sever as unrestricted counters, resulting in undecidable model checking.
          Similarly, we prohibit mutable list variables, as their lengths could be used 
          as counters. %TODO: talk about exponential growth without destructors.
    \item [No variable shadowing] We disallow shadowing of variable names, as it could
          be used to forge the origin of integers, leading to unrestricted comparisons.
          \begin{verbatim}
            \input{programs/eq_from_idxc_shadowing.py}
          \end{verbatim} 
    \item [Functions do not take booleans as arguments.] Since booleans are mutable
          this allow the iterated list to change during the iteration. Depending on the
          semantics of such situation, this could lead to undesirable behavior. For example, 
          it could be used to forge the origin of integers:
          \begin{verbatim}
            \input{programs/eq_from_idxc_shadowing.py}
          \end{verbatim} 
    \item [One way booleans.] Boolean variables are initialized to \texttt{false}, and 
           once they are set to \texttt{true}, they cannot be to \texttt{false}.
           However, during each iteration, all variables declared in the loop are reinitialized to \texttt{false}.
           This restriction allows us to reduce the \kl{model checking problem} to the the satisfiability
           of a \emph{first order} formula on finite words. This problem is not only decidable
           but also solvable by well-engineered existing tools, such as automata-based solvers (e.g., MONA) and classical SMT solvers (e.g., Alt-Ergo, Z3, CVC5).
           Without this restriction, the problem would require the use the MSO logic on words which is still decidable but
           not supported by the SMT solvers.
\end{description}

In order to formally reason about the subset of Python that we want to  model,
we introduce a syntax dedicated to our needs. Let us now discuss its main
ingredients: we explicitly distinguish between boolean, index and list
expressions, and always syntactically group indices with their origin list
(both in the for construction and in the input arguments of functions); we
distinguish between boolean variable introductions (which are always mutable),
and list variable introductions (which are always immutable). To reason about
this, let us first introduce our typing system, which is relatively
straightforward except for the type of the \kl{indices} that is a dependent
type: every index type is associated to a \kl{list expression} from which it
originates. For now, we do not precise the syntax of \kl{list expressions},
which will be given later on.
\begin{align*}
    \tau,\sigma ::=&~ \TBool\\
    \mid&~ \TPos[o] & o \in \oexpr \\
    \mid&~ \TOut[n] & n \in \Nat \\
    \mathsf{arg} ::=&~ (\TOut[n],k) & k \in \Nat \\
    \mathsf{fun} ::=&~ 
           \mathsf{arg}_1 \times \cdots \times \mathsf{arg}_k \to \TBool \\
    \mid&~ \mathsf{arg}_1 \times \cdots \times \mathsf{arg}_k \to \TOut[n] 
\end{align*}

\AP For instance, the function \texttt{getBetweenIndicesBeforeStop(l, i, j)}
that returns all elements of the list $l$ between the indices $i$ and $j$
before the first occurrence of the element \texttt{"stop"} has type
$(\TOut[2],2) \to \TOut[2]$.

\begin{tikzpicture}[remember picture, overlay]
    % put an arc edge between vari -> varl and varj -> varl to show that they point to "l"
    % coordinates are used using (pic cs:vari)  (e.g. (pic cs:vari) |- (pic cs:varl))
    % we want to start the arrows "above" the letters, so we shift the coordinates by 1ex up and 0.5ex left
    % when drawing
    \draw[thick, A2, ->] ([yshift=2ex,xshift=-0.5ex]pic cs:vari) to[out=90,in=90] ([yshift=2ex,xshift=-0.5ex]pic cs:varl);
    \draw[thick, A2, ->] ([yshift=2ex,xshift=-0.5ex]pic cs:varj) to[out=90,in=90] ([yshift=2ex,xshift=-0.5ex]pic cs:varl);
    \draw[thick, A2, ->] ([yshift=2ex,xshift=-0.5ex]pic cs:vark) to[out=90,in=90] ([yshift=2ex,xshift=-0.5ex]pic cs:varenum);
\end{tikzpicture}
\begin{Shaded}
\begin{Highlighting}[numbers=left]
\KeywordTok{def}\NormalTok{ getBetweenIndicesBeforeStop(l\tikzmark{varl}, i\tikzmark{vari}, j\tikzmark{varj}): }
\NormalTok{    seen\_stop }\OperatorTok{=} \VariableTok{False}             \CommentTok{\# initialize a variable to false}
    \ControlFlowTok{for}\NormalTok{ (k\tikzmark{vark}, x) }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(l\tikzmark{varenum}):   }\CommentTok{\# enumerate over a list }
        \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ k }\KeywordTok{and}\NormalTok{ k }\OperatorTok{\textless{}=}\NormalTok{ j:     }\CommentTok{\# compare compatible indices }
            \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \StringTok{"stop"}\NormalTok{:       }\CommentTok{\# compare lists to constants}
\NormalTok{                seen\_stop }\OperatorTok{=} \VariableTok{True}  \CommentTok{\# set booleans to true}
            \ControlFlowTok{if} \KeywordTok{not}\NormalTok{ seen\_stop:     }\CommentTok{\# boolean expressions}
                \ControlFlowTok{yield}\NormalTok{ x           }\CommentTok{\# yielding elements}
\end{Highlighting}
\end{Shaded}


In this example, variables $k$, $i$, and $j$ have type $\TPos[l]$, and $l$ has
type $\TOut[n]$ for some $n > 0$.

Let us immediately provide a semantics for these types, by stating that
$\semT{\TBool} = \Bools$, $\semT{\TPos} = \Nat$ and $\semT{\TOut} = \bigcup_{n
\in \Nat} {{{(\Sigma)}^*}^{\dots}}^{*}$. Indeed, the extra type information in
the positions, namely an origin list expression, is discarded at runtime.

\textbf{TODO: this is a convincing subset of python}

Most of the restrictions listed above are straightforward to check, except for
the origin restriction on the integer variables, which we now will refer to as
indices (since they are always indexing a position of a list). To ensure that
comparisons are well-behaved, we developed a type system that is described 
in figure \todo{write the type system}.
The key idea is that every index variable is created in a for loop statement,
and can therefore be associated to an expression of a list type. Beware that 
we allow comparisons between indices obtained when iterating forward and backward 
the same element.


\textbf{todo write examples of bad programs}

\subsection{Syntax}


\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\bBinOp := &~ \land ~|~ \lor ~|~ \Rightarrow ~|~ \Leftrightarrow \\
        \intro*\pCmpOp := &~ = ~|~ \neq ~|~ < ~|~ \leq ~|~ > ~|~ \geq \\
        \intro*\bexpr :=&~ \intro*\btrue ~|~ \intro*\bfalse ~|~ \bnot{\bexpr} \\
               |&~ \bbin{\bexpr}{\bBinOp}{\bexpr}   \\
               |&~ \bcomp{i}{\pCmpOp}{j} & i,j \in \PVars \\
               |&~ \bapp{f}{\bexpr} & f \in \FunVars \\
               |&~ \bliteq{\cexpr}{\oexpr}
    \end{align*}
    \caption{Boolean expressions.}
    \label{fig:bool-expr}
\end{figure}


\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\cexpr :=&~ \mathsf{char} \; c & c \in \Sigma \\
               |&~ \mathsf{list}(\cexpr_1, \ldots, \cexpr_n)
    \end{align*}
    \caption{Constant expressions.}
    \label{fig:const-expr}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \intro*\oexpr :=&~ x & x \in \OVars \\
               |&~ \cexpr \\
               |&~ \olist{\oexpr_1, \dots,  \oexpr_n}  \\
               |&~ f(\aexpr_1, \dots, \aexpr_n) & f \in \FunVars \\
    \end{align*}
    \caption{Output expressions.}
    \label{fig:out-expr}
\end{figure}

\begin{figure}[h]
    \centering
    \AP
    \begin{align*}
        \intro*\hlstmt :=&~ 
                   \intro*\hlif{\bexpr}{\hlstmt}{\hlstmt} \\
               |&~ \intro*\hlyield{\oexpr} \\
               |&~ \intro*\hlreturn{\oexpr} \\
               |&~ \intro*\hlletoutput{x}{\oexpr}{\hlstmt} & x \in \OVars \\
               |&~ \intro*\hlletboolean{x}{\hlstmt} & x \in \BVars \\
               |&~ \intro*\hlsettrue{x} & x \in \BVars \\
               |&~ \intro*\hlfor{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \intro*\hlforRev{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \intro*\hlseq{\hlstmt}{\hlstmt}
    \end{align*}
    \caption{Control statements.}
    \label{fig:high-level-stmt}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \aexpr :=&~ (\oexpr, p_1, \dots, p_n) & \forall 1 \leq i \leq n, p_i \in \PVars \\
        \hlfun :=&~ \hlfundef{f}{\aexpr_1, \dots, \aexpr_n}{\hlstmt} & f \in \FunVars \\
        \hlprogram :=&~ ([\hlfun_1, \dots, \hlfun_n], f) & f \in \FunVars \\
    \end{align*}
    \caption{High Level For Programs.}
    \label{fig:high-level-program}
\end{figure}


\subsection{Semantics}

\begin{figure}[h]
    \centering
    \begin{align*}
        \semB{ \cdot }{\rho}               \colon&~ \bexpr \to \Bools \\
        \semB{\btrue}{\rho}               =&~ \top \\
        \semB{\bfalse}{\rho}              =&~ \bot \\
        \semB{b}{\rho}                    =&~ \rho(b) & b \in \BVars \\
        \semB{\bnot{b}}{\rho}             =&~ \neg \semB{b}{\rho} \\
        \semB{\bbin{b_1}{op}{b_2}}{\rho}  =&~ \semB{b_1}{\rho} \mathbin{op} \semB{b_2}{\rho} \\
        \semB{\bcomp{i}{op}{j}}{\rho}     =&~ \rho(i) \mathbin{op} \rho(j) \\
        \semB{\bapp{f}{b}}{\rho}          =&~ \semF{f}{\rho}(\semB{b}{\rho}) \\
        \semB{\bliteq{c}{o}}{\rho}        =&~ \semC{c}{\rho} = \semO{o}{\rho}
    \end{align*}
    \caption{Semantics of boolean expressions}.
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semC{ \cdot }                  \colon&~ \cexpr \to \OutputType \\
        \semC{\cchar{c}}                =&~ c \\
        \semC{\clist{c_1, \ldots, c_n}} =&~ [c_1, \ldots, c_n]
    \end{align*}
    \caption{Semantics of constant expressions.}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semO{ \cdot }{\rho}       \colon&~ \oexpr \to \OutputType \\
        \semO{x}{\rho}                  =&~ \rho(x) & x \in \OVars \\
        \semO{\cexpr}{\rho}             =&~ \semC{\cexpr} \\
        \semO{\olist{o_1, \ldots, o_n}}{\rho} =&~ [\semO{o_1}{\rho}, \ldots, \semO{o_n}{\rho}] \\
        \semO{f(\aexpr_1, \dots, \aexpr_n)}{\rho} =&~ \semF{f}{\rho}(\semO{\aexpr_1}{\rho}, \dots, \semO{\aexpr_n}{\rho})
    \end{align*}
    \caption{Semantics of output expressions.}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semC{\cdot}{\rho} \colon&~ \hlstmt \to \rho \to \rho \\
    \end{align*}
    \caption{Semantics of control statements.}
    \label{fig:semantics-control}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semF{\cdot}{\rho} \colon&~ \hlfun \to \rho \to \rho \\
        \semF{\hlfundef{f}{\aexpr_1, \dots, \aexpr_n}{\hlstmt}}{\rho} =&~ \lambda x_1, \dots, x_n. \semC{\hlstmt}{\rho[x_1 \mapsto \semO{\aexpr_1}{\rho}, \dots, x_n \mapsto \semO{\aexpr_n}{\rho}]}
    \end{align*}
    \caption{Semantics of functions.}
    \label{fig:semantics-functions}
\end{figure}

\begin{figure}
\end{figure}


% Basic typing judgments
\begin{prooftree}
\AxiomC{}
\RightLabel{(T-True)}
\UnaryInfC{$\Gamma \vdash \btrue : \TBool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(T-False)}
\UnaryInfC{$\Gamma \vdash \bfalse : \TBool$}
\end{prooftree}

% Boolean expressions
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\RightLabel{(T-Not)}
\UnaryInfC{$\Gamma \vdash \bnot{e} : \TBool$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1 : \TBool$}
\AxiomC{$\Gamma \vdash e_2 : \TBool$}
\RightLabel{(T-BBin)}
\BinaryInfC{$\Gamma \vdash \bbin{e_1}{\odot}{e_2} : \TBool$}
\end{prooftree}

% Position comparisons
\begin{prooftree}
\AxiomC{$\Gamma(i) = \TPos[o_i]$}
\AxiomC{$\Gamma(j) = \TPos[o_j]$}
\AxiomC{$o_i = o_j$}
\RightLabel{(T-PComp)}
\TrinaryInfC{$\Gamma \vdash \bcomp{i}{\odot}{j} : \TBool$}
\end{prooftree}

% Function application in boolean expressions
\begin{prooftree}
\AxiomC{$\Delta(f) = (\tau_1,\ldots,\tau_n) \to \TBool$}
\AxiomC{$\Gamma \vdash e : \tau_1$}
\RightLabel{(T-BApp)}
\BinaryInfC{$\Gamma \vdash \bapp{f}{e} : \TBool$}
\end{prooftree}

% Output expressions
\begin{prooftree}
\AxiomC{$\Gamma(x) = \TOut[n]$}
\RightLabel{(T-OVar)}
\UnaryInfC{$\Gamma \vdash x : \TOut[n]$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \vdash e_i : \TOut[n]$ for all $i$}
\RightLabel{(T-OList)}
\UnaryInfC{$\Gamma \vdash \olist{e_1,\ldots,e_n} : \TOut[n+1]$}
\end{prooftree}

% Statements
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\AxiomC{$\Gamma \vdash s_1 : \tau$}
\AxiomC{$\Gamma \vdash s_2 : \tau$}
\RightLabel{(T-If)}
\TrinaryInfC{$\Gamma \vdash \hlif{e}{s_1}{s_2} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\RightLabel{(T-Yield)}
\UnaryInfC{$\Gamma \vdash \hlyield{e} : \TOut[n+1]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\RightLabel{(T-Return)}
\UnaryInfC{$\Gamma \vdash \hlreturn{e} : \TOut[n]$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TBool$}
\RightLabel{(T-Return)}
\UnaryInfC{$\Gamma \vdash \hlreturn{e} : \TBool$}
\end{prooftree}

% Let bindings
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \TOut[n]$}
\AxiomC{$\Gamma, x:\TOut[n] \vdash s : \tau$}
\RightLabel{(T-LetOut)}
\BinaryInfC{$\Gamma \vdash \hlletoutput{x}{e}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma, x:\TBool \vdash s : \tau$}
\RightLabel{(T-LetBool)}
\UnaryInfC{$\Gamma \vdash \hlletboolean{x}{s} : \tau$}
\end{prooftree}

% For loops
\begin{prooftree}
\AxiomC{$\Gamma \vdash o : \TOut[n]$}
\AxiomC{$\Gamma, i:\TPos[o], x:\TOut[n] \vdash s : \tau$}
\AxiomC{$n > 0$}
\RightLabel{(T-For)}
\TrinaryInfC{$\Gamma \vdash \hlfor{(i,x)}{o}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash o : \TOut[n]$}
\AxiomC{$\Gamma, i:\TPos[o], x:\TOut \vdash s : \tau$}
\AxiomC{$n > 0$}
\RightLabel{(T-ForRev)}
\TrinaryInfC{$\Gamma \vdash \hlforRev{(i,x)}{o}{s} : \tau$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(T-SetTrue)}
\UnaryInfC{$\Gamma \vdash \hlsettrue{x} : \tau$}
\end{prooftree}

% Sequence
\begin{prooftree}
\AxiomC{$\Gamma \vdash s_1 : \tau$}
\AxiomC{$\Gamma \vdash s_2 : \tau$}
\RightLabel{(T-Seq)}
\BinaryInfC{$\Gamma \vdash \hlseq{s_1}{s_2} : \tau$}
\end{prooftree}

% Function definition
\begin{prooftree}
\AxiomC{$\Gamma \vdash \aexpr_i : \tau_i$ for all $i$}
\AxiomC{$\Gamma \vdash s : \tau$}
\RightLabel{(T-Fun)}
\BinaryInfC{$\Delta \vdash \hlfundef{f}{(\aexpr_1,\ldots,\aexpr_n)}{s} : (\tau_1,\ldots,\tau_n) \to \tau$}
\end{prooftree}

% Program
\begin{prooftree}
\AxiomC{$\Delta \vdash \hlfun_i : \tau_i$ for all $i$}
\AxiomC{$f \in \FunVars$}
\RightLabel{(T-Prog)}
\BinaryInfC{$\vdash ([\hlfun_1,\ldots,\hlfun_n], f) : \tau_f$}
\end{prooftree}
