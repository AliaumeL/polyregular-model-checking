\section{High Level For Programs}
\label{sec:high_level}

\begin{itemize}
    \item Explain that we want to consider list-manipulating functions
          that only exhibit polynomial growth.
    \item Introduce the syntax
    \item Give an example of a high level for program
    \item Give an operational / denotational semantics
    \item Explain the typing system
    \item Illustrate the type system with an example + counter-example for polynomial growth
\end{itemize}

\section{High Level For Programs}
\label{sec:high_level}

\begin{itemize}
    \item Explain that we want to consider list-manipulating functions
          that only exhibit polynomial growth.
    \item Introduce the syntax
    \item Give an example of a high level for program
    \item Give an operational / denotational semantics
    \item Explain the typing system
    \item Illustrate the type system with an example + counter-example for polynomial growth
\end{itemize}


\subsection{Syntax}

\NewDocumentCommand{\PVars}{}{\mathbb{V}_{\text{pos}}}
\NewDocumentCommand{\FunVars}{}{\mathbb{V}_{\text{fun}}}
\NewDocumentCommand{\BVars}{}{\mathbb{V}_{\text{bool}}}
\NewDocumentCommand{\OVars}{}{\mathbb{V}_{\text{out}}}

\NewDocumentCommand{\Bools}{}{\mathbb{B}}
\NewDocumentCommand{\OutputType}{O{\Sigma}}{\mathcal{C}_{#1}}

\NewDocumentCommand{\hlprogram}{}{\mathsf{Program}}
\NewDocumentCommand{\hlfun}{}{\mathsf{Fun}}
\NewDocumentCommand{\hlstmt}{}{\mathsf{Stmt}}
\NewDocumentCommand{\bexpr}{}{\mathsf{BExpr}}
\NewDocumentCommand{\oexpr}{}{\mathsf{OExpr}}
\NewDocumentCommand{\cexpr}{}{\mathsf{CExpr}}
\NewDocumentCommand{\aexpr}{}{\mathsf{AExpr}}

\NewDocumentCommand{\bBinOp}{}{\mathsf{BBin}}
\NewDocumentCommand{\pCmpOp}{}{\mathsf{PComp}}

\NewDocumentCommand{\hlif}{m m m}{\mathsf{if} \; #1 \; \mathsf{then} \; #2 \; \mathsf{else} \; #3}
\NewDocumentCommand{\hlyield}{m}{\mathsf{yield} \; #1}
\NewDocumentCommand{\hlreturn}{m}{\mathsf{return} \; #1}
\NewDocumentCommand{\hlletoutput}{m m m}{\mathsf{let} \; #1 = #2 \; \mathsf{in} \; #3}
\NewDocumentCommand{\hlletboolean}{m m}{\mathsf{let~mut} \; #1 = \bfalse \; \mathsf{in} \; #2}
\NewDocumentCommand{\hlsettrue}{m}{\; #1 \; \leftarrow \; \mathsf{true}}
\NewDocumentCommand{\hlfor}{m m m}{\mathsf{for}^{\rightarrow} \; #1 \; \mathsf{in} \; #2 \; \mathsf{do} \; #3}
\NewDocumentCommand{\hlforRev}{m m m}{\mathsf{for}^{\leftarrow} \; #1 \; \mathsf{in} \; #2 \; \mathsf{do} \; #3}
\NewDocumentCommand{\hlseq}{m m }{ #1 \; ; \; #2}


\NewDocumentCommand{\btrue}{}{\mathsf{true}}
\NewDocumentCommand{\bfalse}{}{\mathsf{false}}
\NewDocumentCommand{\bnot}{m}{\neg #1}
\NewDocumentCommand{\bbin}{ m m m }{#1 \; #2 \; #3}
\NewDocumentCommand{\bcomp}{m m m}{#1 \; #2 \; #3}
\NewDocumentCommand{\bapp}{m m}{\mathop{#1}(#2)}
\NewDocumentCommand{\bliteq}{m m}{#1 \; = \; #2}
\NewDocumentCommand{\bgen}{m}{\langle #1 \rangle}


\NewDocumentCommand{\ogen}{m}{\langle #1 \rangle}
\NewDocumentCommand{\cchar}{m}{\mathsf{char}(#1)}
\NewDocumentCommand{\clist}{m}{\mathsf{list}(#1)}
\NewDocumentCommand{\olist}{m}{\mathsf{list}(#1)}

\NewDocumentCommand{\hlfundef}{m m m}{\mathsf{def} \; #1(#2) \; \{ #3 \}}



\begin{figure}[h]
    \centering
    \begin{align*}
        \bBinOp := &~ \land ~|~ \lor ~|~ \Rightarrow ~|~ \Leftrightarrow \\
        \pCmpOp := &~ = ~|~ \neq ~|~ < ~|~ \leq ~|~ > ~|~ \geq \\
        \bexpr :=&~ \btrue ~|~ \bfalse ~|~ \bnot{\bexpr} \\
               |&~ \bbin{\bexpr}{\bBinOp}{\bexpr}   \\
               |&~ \bcomp{i}{\pCmpOp}{j} & i,j \in \PVars \\
               |&~ \bapp{f}{\bexpr} & f \in \FunVars \\
               |&~ \bliteq{\cexpr}{o} & o \in \OVars \\
               |&~ \bgen{\hlstmt} 
    \end{align*}
    \caption{Boolean expressions.}
\end{figure}


\begin{figure}[h]
    \centering
    \begin{align*}
        \cexpr :=&~ \mathsf{char} \; c & c \in \Sigma \\
               |&~ \mathsf{list}(\cexpr_1, \ldots, \cexpr_n)
    \end{align*}
    \caption{Constant expressions.}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \oexpr :=&~ x & x \in \OVars \\
               |&~ \cexpr \\
               |&~ \olist{o_1, \ldots, o_n} & \forall 1 \leq i \leq n, o_i \in \OVars \\
               |&~ f(\aexpr_1, \dots, \aexpr_n) & f \in \FunVars \\
               |&~ \ogen{\hlstmt}
    \end{align*}
    \caption{Output expressions.}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \hlstmt :=&~ \hlif{\bexpr}{\hlstmt}{\hlstmt} \\
               |&~ \hlyield{\oexpr} \\
               |&~ \hlreturn{\oexpr} \\
               |&~ \hlletoutput{x}{\oexpr}{\hlstmt} & x \in \OVars \\
               |&~ \hlletboolean{x}{\hlstmt} & x \in \BVars \\
               |&~ \hlsettrue{x} & x \in \BVars \\
               |&~ \hlfor{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \hlforRev{(i,x)}{\oexpr}{\hlstmt} & (i,x) \in \PVars \times \OVars \\
               |&~ \hlseq{\hlstmt}{\hlstmt}
    \end{align*}
    \caption{Control statements.}
\end{figure}

\begin{figure}[h]
    \centering
    \begin{align*}
        \aexpr :=&~ (\oexpr, p_1, \dots, p_n) & \forall 1 \leq i \leq n, p_i \in \PVars \\
        \hlfun :=&~ \hlfundef{f}{\aexpr_1, \dots, \aexpr_n}{\hlstmt} & f \in \FunVars \\
        \hlprogram :=&~ ([\hlfun_1, \dots, \hlfun_n], f) & f \in \FunVars \\
    \end{align*}
    \caption{High Level For Programs.}
\end{figure}


\subsection{Semantics}

\NewDocumentCommand{\semB}{ m m }{ \llbracket #1 \rrbracket_{#2} }
\NewDocumentCommand{\semS}{ m m }{ \llbracket #1 \rrbracket_{#2} }
\NewDocumentCommand{\semO}{ m m }{ \llbracket #1 \rrbracket_{#2} }
\NewDocumentCommand{\semC}{ m }{ \llbracket #1 \rrbracket }
\NewDocumentCommand{\semF}{ m m }{ \llbracket #1 \rrbracket_{#2} }

\begin{figure}[h]
    \centering
    \begin{align*}
        \semB{ \cdot }{\rho}               \colon&~ \bexpr \to \Bools \\
        \semB{\btrue}{\rho}               =&~ \top \\
        \semB{\bfalse}{\rho}              =&~ \bot \\
        \semB{b}{\rho}                    =&~ \rho(b) & b \in \BVars \\
        \semB{\bnot{b}}{\rho}             =&~ \neg \semB{b}{\rho} \\
        \semB{\bbin{b_1}{op}{b_2}}{\rho}  =&~ \semB{b_1}{\rho} \mathbin{op} \semB{b_2}{\rho} \\
        \semB{\bcomp{i}{op}{j}}{\rho}     =&~ \rho(i) \mathbin{op} \rho(j) \\
        \semB{\bapp{f}{b}}{\rho}          =&~ \semF{f}{\rho}(\semB{b}{\rho}) \\
        \semB{\bliteq{c}{o}}{\rho}        =&~ \semC{c}{\rho} = \semO{o}{\rho} \\
        \semB{\bgen{s}}{\rho}             =&~ \semS{s}{\rho}
    \end{align*}
    \caption{Semantics of boolean expressions}.
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semC{ \cdot }                  \colon&~ \cexpr \to \OutputType \\
        \semC{\cchar{c}}                =&~ c \\
        \semC{\clist{c_1, \ldots, c_n}} =&~ [c_1, \ldots, c_n]
    \end{align*}
    \caption{Semantics of constant expressions.}
\end{figure}

\begin{figure}
    \centering
    \begin{align*}
        \semO{ \cdot }{\rho}       \colon&~ \oexpr \to \OutputType \\
        \semO{x}{\rho}                  =&~ \rho(x) & x \in \OVars \\
        \semO{\cexpr}{\rho}             =&~ \semC{\cexpr} \\
        \semO{\olist{o_1, \ldots, o_n}}{\rho} =&~ [\semO{o_1}{\rho}, \ldots, \semO{o_n}{\rho}] \\
        \semO{f(\aexpr_1, \dots, \aexpr_n)}{\rho} =&~ \semF{f}{\rho}(\semO{\aexpr_1}{\rho}, \dots, \semO{\aexpr_n}{\rho}) \\
        \semO{\ogen{s}}{\rho}           =&~ \semS{s}{\rho}
    \end{align*}
    \caption{Semantics of output expressions.}
\end{figure}
