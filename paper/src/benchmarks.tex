\section{Benchmarks}
\label{sec:benchmarks}

We implemented all the transformations expressed in this paper. In particular,
we transformed \kl{high-level for-programs} into \kl{first-order
interpretations} which where then used to verify \kl{first-order Hoare triples}
using an SMT solver or the \kl{MONA} program. In this section, we will present
key indicators of these transformations, and ignore the time taken by the
solvers to perform verification as it is for now out of the scope of this
paper.

We selected a number of programs in the \kl{high-level for-program} language
and for each of them we computed its corresponding \kl{simple for-program} and
its corresponding \kl{first-order interpretation}. To measure the complexity of
these transformations, we associated to a \kl{high-level for-program} the
following parameters: its \emph{size} (number of control flow statements), its
\emph{loop depth} (the maximum number of nested loops), and its \emph{boolean
depth} (the maximum number of boolean variables visible at any point in the
program). We compute the same parameters for the corresponding \kl{simple
for-program}. In the case of \kl{first-order interpretations}, we only compute
its \emph{size} (number of nodes in the formula) and its \kl{quantifier rank}.
The results are presented in \cref{tab:benchmarks}.

\paragraph{Quantifier free results.}
In the simplest cases, we do manage to obtain the optimal quantifier
free results.

\paragraph{Non-symmetric results.} Get first word and get last words
are two programs that are very similar in their high-level
representation, but the quantifier rank and number of boolean variables
highly differ.

\paragraph{Complexity of literals.}
The results show that the \kl{elimination of literals} is responsible for a
significant increase in the complexity of the formulas, as one can see in the
\texttt{assets/HighLevel/litteral\_test.pr} benchmark. This is explained by the
fact that the elimination of literals introduces a \emph{sequential} structure
in the program which is simulated by introducing boolean variables.



Similarly, we observe that our transformation does not introduce any
quantifiers when boolean variables are not used, this is the case for the
\texttt{reversed\_add\_hash} benchmark. 

\subsection{Evaluation of Hoare Triple}
While we did not use extensive testing, 
we did witness that ... on the examples X and Y, 
results in table XX. So the use of different solvers really is interesting.


\begin{description}
    \item[High Level transformation]
        We compute for the output
        \begin{itemize}
            \item The time it took to transform the program (plot)
            \item The size of the output program (ratio)
            \item The nesting depth of for loops (ratio)
            \item The number of print statements (ratio)
        \end{itemize}
    \item[Low level to interpretation]
        We compute for the output
        \begin{itemize}
            \item The time it took to transform the program (plot)
            \item The size of the formula (ratio)
            \item The quantifier rank of the formula (ratio)
        \end{itemize}
    \item[Interpretation to SMT]
        We compute for the output
        \begin{itemize}
            \item The time it took to transform the program (plot)
            \item The size of the formula (ratio)
            \item The quantifier rank of the formula (ratio)
        \end{itemize}
\end{description}

\begin{table}
    \caption{Benchmark results for the transformations. 
        Here \kl[for program]{FP} is a \kl{high-level program},
        \kl[simple for-program]{S.FP} is a \kl{simple for-program},
        and \kl[first-order interpretation]{$\FO$-I} is a \kl{first-order interpretation}.
        The columns \textbf{size}, \textbf{l.d.}, and \textbf{b.d.} stand for the size, loop depth, and boolean depth respectively. While the columns \textbf{size} and \textbf{q.r.} stand for the size and \kl{quantifier rank} of the 
        \kl{first-order interpretation} respectively.
    }
    \label{tab:benchmarks}
    \centering
    \input{figs/benches.tex}
\end{table}

