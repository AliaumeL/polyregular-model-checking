% LTeX: language=EN
\section{From High Level to Low Level For Programs}
\label{sec:htl}

\AP In this section, we provide a compilation from high level to low level For
programs. One of the main differences between the two languages is the lack of
functions in the latter. To smoothen the conversion between the two, we
introduce a new constructon to the language, that are \intro{generator
expressions}, representing the evaluation of a function on a given input.
Namely, we add the constructor $\intro*\ogen{s}$, and $\intro*\bgen{s}$ respectively to the
syntax of \kl{list expressions} and \kl{boolean expressions}. 

\paragraph{Generator Expressions.} Let us briefly discuss the new typing rules
and semantics of these \kl{generator expressions}. The intended meaning of a
generator expression $\ogen{s}$ is to evaluate the statement $s$ in the current
context and collect its output. For instance, $\ogen{\hlreturn{x}}$ is
equivalent to $x$, and $\ogen{\hlseq{\hlyield{x}}{\hlyield{y}}}$ is equivalent
to $\olist{x,y}$. The semantics are similarly defined for \kl{boolean
expressions}. It should therefore not be surprising that if a
\kl[hl]{statement} has type $\TOut[n]$, then the \kl{generator expression}
$\ogen{s}$ also has type $\TOut[n]$ (and similarly for \kl{boolean
expressions}). However, there is one key ingredient in the semantics of such
expressions: when evaluating the statement $s$, we hide all boolean variables
from the \kl{evaluation context}. In particular,
$\hlletboolean{b}{\hlreturn{\bgen{ \hlreturn{b} }}}$ is an \emph{invalid
program}, because the variable $b$ is undefined in the context of the generator
expression $\bgen{b}$. We refer the reader to the appendix and
\cref{fig:generators} for the formal definitions of the typing rules and
semantics of these expressions. The key lemma implied by this design choice is
that the evaluation order for expressions is irrelevant, which heavily relies
on the fact that only boolean variables are mutable
(\ref{item:mut-variables}).

\begin{lemma}
    \label{lem:gen-indep-bool}
    For every \kl{list expression} $e$, \kl{boolean expression} $b$,
    variable $x_e \in \OVars$, variable $x_b \in \BVars$, \kl{evaluation
    environment} $\rho$, and statement $s$, the following equality holds:
    \begin{equation*}
        \semS{ s[x_e \mapsto e, x_b \mapsto b] }{\rho}
        =
        \semS{ s }{\rho[x_e \mapsto \semO{e}{\rho}, x_b \mapsto \semB{b}{\rho}]}
    \end{equation*}
\end{lemma}

\paragraph{Rewriting Steps.} We will convert \kl{high level programs} to
\kl{low level programs} by a series of rewriting steps which we 
list hereafter, briefly explaining how they are performed.
Note that while most of the steps can be applied to any \kl{high level
program}, we will focus on programs
of type $(\TOut[1],0) \to (\TOut[1],0)$, since they ultimately will
be converted to \kl{simple for-programs}.
\begin{enumerate}[label=(\Alph*), ref=Step \Alph*]
    \item \label{item:lit_eq_elim} \intro{Elimination of Literal
        Equalities}, i.e., of expressions $\bliteq{c}{o}$ where $c \in \cexpr$
        and $o \in \oexpr$. This is done by replacing those tests with a call
        to a function that checks for equality with the constant $c$ by
        traversing its input. Such functions are defined in
        \cref{lem:constequality}.
        Note that this is only possible because equalities are always
        between a variable and a constant (\ref{item:equality-checks}).

    \item \label{item:lit_elim} \intro{Elimination of Literal
        Productions}, i.e., of constant expressions in the construction of
        $\oexpr$, except single characters. This is done by replacing a
        constant $c$ by a call to a function that produces the constant $c$.
        For instance, $\clist{\cchar{a_1}, \cchar{a_2}}$ is replaced by a call
        to a function with body
        $\hlseq{\hlyield{\cchar{a_1}}}{\hlyield{\cchar{a_2}}}$.


    \item \label{item:fun_elim} \intro{Elimination of Function Calls},
        by replacing them with \kl{generator expressions}. Given a function $f$
        with body $s$ and arguments $x_1, \dots, x_n$, we replace a call
        $f(a_1, \dots, a_n)$ by $\ogen{ s[ a_1/x_1, \dots, a_n/x_n ] }$
        (respectively, using $\bgen{ \cdots }$, for boolean functions). This is
        valid because function cannot take booleans as arguments
        (\ref{item:boolean-arguments}). A formal statement of this
        fact is available in \cref{lem:fungenexpr}.


    \item \label{item:bool_elim} \intro{Elimination of Boolean
        Generators}, i.e., of expressions $\bgen{s}$. Note that the only
        occurences of $\bgen{s}$ are in \kl{boolean expressions}, which are
        only used in the conditional tests. For instance, the conditional test
        $\hlif{\bgen{s_1}}{s_2}{s_3}$ is replaced by $\hlletboolean{b_1}{
        (\hlseq{s_1'}{\hlif{b_1}{s_2}{s_3}}) }$, where $s_1'$ is obtained by
        replacing boolean return statements $(\hlreturn{b)}$ by assignments of
        the form $(\hlif{b}{\hlsettrue{b_1}}{})$. This is valid because of
        \cref{lem:gen-indep-bool}.

    \item \label{item:let_output_elim} \intro{Elimination of Let
        Output Statements}, i.e., of statements of the form
        $\hlletoutput{x}{e}{s}$. This is done by textually replacing
        $\hlletoutput{x}{e}{s}$ by $s[x \mapsto e]$, which is valid because of
        \cref{lem:gen-indep-bool}.


    \item \label{item:return_elim} \intro{Elimination of Return
        Statements} for \kl{list expressions}. The idea is to replace returns
        by yield statements, and add a boolean variable \texttt{has\_returned}
        to prevent further outputs after the first return statement is reached.
        This works for expressions of type $\TOut[n]$ where $n > 0$, because
        one can replace $\hlreturn{e}$ by
        $\hlif{\bnot{\texttt{has\_returned}}}{\hlseq{\hlsettrue{\texttt{has\_returned}}}{s'}}$,
        where $s' = \hlfor{(i,x)}{e}{\hlyield{x}}$. The conversion is slightly
        more involved for returns of type $\TOut[0]$, and we refer the readers
        to our implementation for the details of this case. Its completeness
        relies on the fact that the final program is of type $(\TOut[1],0) \to
        (\TOut[1],0)$.


    \item \label{item:for_loop_exp} \intro{Expansion of For Loops},
        i.e., ensuring that every for loop iterates over a single \kl{list
        variable}. The most complex case being
        $\hlforRev{(i,x)}{\ogen{s_1}}{s_2}$. This rewriting step will be
        thouroughly explained in the upcoming section.

    \item \label{item:let_bools_top} 
        \intro{Defining booleans at the beginning of for loops}.
        Because there is no shadowing of variable
        names (\ref{item:variable-shadowing}),
        the following programs are equivalent:
        $(\hlseq{s_1}{\hlletboolean{b}{s_2}})$
        and
        $\hlletboolean{b}{(\hlseq{s_1}{s_2})}$. Similarly, for 
        the $\hlif{\cdot}{\cdot}{\cdot}$ construct.
        As a consequence, one can always move boolean definitions to the 
        first for loop in which they are defined.
\end{enumerate}

\begin{lemma}
    \label{lem:constequality}
    For every
    constant expression $c \in \cexpr$ of type $\TOut[n]$, there exists a \kl{high
    level function} $f_c$ of type $(\TOut[n], 0) \to \TBool$ such that
    $\semB{f_c(o)}{\rho} = \semB{\bliteq{c}{o}}{\rho}$ for every $o \in \oexpr$ and
    \kl{evaluation environment} $\rho$. Such functions are defined by induction on
    $c$, using a simple pattern matching.
\end{lemma}


\begin{theorem}
    \label{thm:rewriting-termination}
    The rewriting steps (\ref{item:lit_eq_elim}--- \ref{item:let_bools_top})
    all terminate and preserve typing, and a fully normalized \kl{high level for program}
    of type $(\TOut[1],0) \to (\TOut[1],0)$
    satisfies the following properties:
    \begin{itemize}
        \item It only iterates over its input or the reverse of its input;
        \item It contains no \kl{generator expressions};
        \item All introduced variables are boolean and introduced at the top level
            or at the beginning of a for loop;
        \item There are no return statements, and the only
            yield are of type character and contain either a constant
            or a variable.
    \end{itemize}
\end{theorem}

Now, it is clear that this sub-language of for-programs corresponds
to the simple-for-programs described in the previous section, hence
we have effectively obtained the following corollary:

\begin{corollary}
    Every \kl{high level program} of type $(\TOut[1],0) \to (\TOut[1],0)$
    is (effectively) computable by a \kl{simple for-program}.
\end{corollary}

\begin{corollary}
    Every \kl{high level program} has \kl{polynomial growth},
    and the \kl{model checking problem} is decidable for 
    \kl{high level programs}.
\end{corollary}


\paragraph{Forward For Loop Expansion.} We now focus on the \kl{expansion of for
loops}, that is, \ref{item:for_loop_exp}. The case of forward
iterations is simpler and will illustrate a first difficulty. We whish to
replace a loop form $\hlfor{(i,x)}{\ogen{s_1}}{s_2}$ by the statement $s_1$
where every statement $\hlyield{e}$ is replaced by $s_2[x \mapsto e]$. This
rewriting is problematic because it leaves the variable $i$ undefined in $s_2$.
The key observation allowing us to circumvent this issue is that the variable
$i$ can only be used in \emph{comparisons} of the form $\bcomp{i}{\pCmpOp}{j}$
inside \kl{boolean expressions}. Because of our restriction on the usage of
\kl{position variables} (\ref{item:integer-comparisons}), $i$ and $j$
can only be compared if originate from the same \kl{list expression}. In
particular, this means that $i$ can only be compared to a variable $j$ that is
iterating over $\ogen{s_1}$. This means that one only needs to be able to order
the outputs of $s_1$ to effectively replace the comparisions using the variable
$i$.

One can recover the ordering between outputs of a statement $s_1$ by storing
the position of the $\hlyield{e}$ responsible for the output, together with the
values of all position variables introduced by $s$ at that point. Let us show
how this can be done in a simple example:
\begin{equation*}
    \hlseq{
    (\hlforRev{(j\tikzmark{yieldIndex},y)}{e}{
        (\hlseq{\tikzmark{yield1}\hlyield{y}}
               {\tikzmark{yield2}\hlyield{\cchar{a}}}
        )})
    }{\tikzmark{yield3}\hlyield{\cchar{b}}}
\end{equation*}
\begin{tikzpicture}[overlay, remember picture]
    % Y1 below = 0.5cm, left 0.3cm of pic cs:yield1
    \node (Y1) at ([yshift=-0.5cm, xshift=0.2cm]pic cs:yield1) {$p_1(j)$};
    \node (Y2) at ([yshift=-0.5cm, xshift=0.2cm]pic cs:yield2) {$p_2(j)$};
    \node (Y3) at ([yshift=-0.5cm, xshift=0.2cm]pic cs:yield3) {$p_3$};
    \node (YI) at ([yshift=0cm, xshift=-0.2cm]pic cs:yieldIndex) {};

    \draw[dashed, A2, thick] (Y1) edge[->, bend left] (YI);
    \draw[dashed, A2, thick] (Y2) edge[->, bend left] (YI);
\end{tikzpicture}
\vspace{1em}

In this example, there are three yield statements at
positions $p_1$, $p_2$ and $p_3$. We can compute
the happens (strictly) before relation between outputs 
of the various yield statements:
\begin{itemize}
    \item $\mathsf{happensBefore}(p_1(j), p_3) = \btrue$;
    \item $\mathsf{happensBefore}(p_2(j), p_3) = \btrue$;
    \item $\mathsf{happensBefore}(p_1(j), p_2(j')) =
        j \geq j'$.
\end{itemize}
In the case of $j = j'$, the 
output of $p_1(j)$ happens before the output of $p_2(j')$,
because $p_1$ is the first yield statement in the loop.
When $j > j'$, the output of $p_1(j)$ happens
before the output of $p_2(j')$ because the loop
is iterating in reverse order.

\paragraph{Backward For Loop Expansion.} The case of backward iterations adds a
new layer of complexity, mainly to perform a non-reversible computation $s$ in
a reversed order: indeed $s$ can contain the command $\hlsettrue{b}$ which
cannot be reversed in our language. Let us consider as an example
$\hlforRev{(i,x)}{\ogen{s}}{\hlyield{x}}$, where the statement $s$ is defined
to print all elements of a list $u$ except the first one, namely:
$\hlletboolean{b}{\hlfor{(j,y)}{ u }{\hlif{b}{\hlyield{y}}{\hlsettrue{b}}}}$.
The semantics of $\hlforRev{(i,x)}{\ogen{s}}{\hlyield{x}}$ is to print all
elements of $u$ in reverse order, skipping the last loop iteration. To compute
this new statement, we will use the following \emph{trick} that can be traced
back to \cite[Lemma 8.1 and Figure 6, p. 68]{bojanczyk2018polyregular}: we will
use two versions of the statement $s$, the first one $s_\mathsf{rev}$, will be
$s$ where all boolean introductions are removed, if statements
$\hlif{e}{s_1}{s_2}$ are replaced by sequences $\hlseq{s_1}{s_2}$, every loop
direction is swapped, and every sequence of statements is reversed. Its
intended semantics is to reach all possible yield statements of $s$ in the
reversed order. 
In our case, $s_\mathsf{rev}$ is defined as:
\begin{equation*}
    \hlforRev{(j',y')}{ u }{\hlyield{y'}}
\end{equation*}
Remark that there are some statements that are reachable in
$s_\mathsf{rev}$, but do not correspond to a production when iterating over $s$
in reverse order, because of the boolean variables and conditionals that we
discarded. To ensure that we only output correct elements,
we will replace every $\hlyield{\cdot}$ statement in $s_{\mathsf{rev}}$ by a
copy of $s$, leading to the program $s' = s_{\mathsf{rev}}[ \hlyield{\cdot} \mapsto s ]$.
In our case, this leads to the following program:
\begin{align*}
    \hlforRev{(j',y')}{ u }{ s }
\end{align*}
It is now possible to replace every yield statement in this new program
by a conditional check ensuring that the output would actually be 
produced by the original program $s$.
\begin{equation*}
    s'' = s'[ \hlyield{e} \mapsto \hlifnoelse{\bcomp{i}{=}{j'}}{\hlyield{e}}]
\end{equation*}
In our case, the final program is the following one:
\begin{align*}
    &\mathsf{for}^{\leftarrow}~(j',y')~\mathsf{in}~ u ~\mathsf{do} \\
    &\quad \mathsf{for}^{\rightarrow}~(j, y)~\mathsf{in}~ u ~\mathsf{do} \\
    &\quad \quad \mathsf{let}~\mathsf{mut}~b = \mathsf{false}~\mathsf{in} \\
    &\quad \quad \mathsf{if} \; b \; \mathsf{then} \\
    &\quad \quad \quad \mathsf{if} \; j = j' \; \mathsf{then} \\
    &\quad \quad \quad \quad \mathsf{yield}~y \\
    &\quad \quad \mathsf{else} \\
    &\quad \quad \quad b \leftarrow \mathsf{true}
\end{align*}
This rewriting can be generalised to any program of the form
$\hlforRev{(i,x)}{\ogen{s_1}}{s_2}$ combining the construction illustrated here
with the one taking care of position variables in the case of forward loops.
