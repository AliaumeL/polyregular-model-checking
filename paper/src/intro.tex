% LTeX: language=EN
\section{Introduction}
\label{sec:intro}

\paragraph{Motivation.} Verification is important. And it is hard. People have
tried to make it easier. We are focusing on programs that do not use the full
power of Turing machine and this is not absurd:
\begin{itemize}
    \item Configuration management
    \item Simple string rewriting programs
    \item "Extract transform load" pipelines
\end{itemize}
For these programs one wants to certify their behaviour,
for instance using \intro{Hoare triples}
$\hoaretriple{P}{\texttt{code}}{Q}$
where $P$ and $Q$ are predicates and \texttt{code} is a program,
meaning that whenever the input satisfies property $P$,
the output of the program satisfies property $Q$.

\AP When the language is expressive enough, which is our case, this can be
reduced to the problem of \intro{model checking}. The crucial property of
\kl{high-level language} it hat it has decidable \intro{model checking
problem}: given a function $f \colon X \to \Bools$, we can decide whether there
exists $x \in X$ such that $f(x) = \btrue$.

\paragraph{SMT solvers and Logic on Words.} 
\AP
\intro{MONA} \cite{MONA01}, \intro{Z3} \cite{z3},
\intro{CVC5} \cite{cvc5}. \intro{Alt-Ergo} \cite{HOARE69}.

\paragraph{Contributions.} 
\begin{itemize}
    \item Introduced a high level language that is close to Python and 
        suitable for model checking.
    \item Our language is modular and contains functions, enabling for a clear
        and concise implementation.
    \item Effectively proved equivalence of the high-level language with an existing
        model (polyregular functions), building a conversion algorithm.
    \item Implemented a model checking algorithm for polyregular functions,
        by reducing it to the satisfiability of a first-order formula on finite words.
    \item We tested our program on examples using different backends to solve
        the resulting formulas (CVC5, Z3, Alt-Ergo and Mona), showing
        their complementarity.
\end{itemize}
\cite{z3} \cite{cvc5}
\cite{HOARE69}
\cite{MONA01}

\begin{center}
    \begin{tikzpicture}[
        syntaxNode/.style={
                    rectangle, draw, 
                    text width=5em, 
                    text centered, 
                    rounded corners, 
                    minimum height=4em}
    ]
        %
        % Write a tikz picture with nodes explaining the different 
        % steps of the rewriting system 
        % 
        % (a) high-level language
        % (b) simple for-programs
        % (c) first-order string-to-string interpretations
        % (c1) precondition
        % (c2) postcondition
        % (d) first-order formula
        \node[syntaxNode] (a) {\kl{For program}};
        \node[syntaxNode, right=of a] (b)  {\kl{Simple for-program}};
        \node[syntaxNode, right=of b] (c)  {\kl{$\FO$ interpretation}};
        \node[syntaxNode, right=of c] (d) {\kl{First-order formula}};

        \draw[->] (a) -- node[above,rotate=90,xshift=2.3em,yshift=-0.3em] {\cref{sec:htl}} (b);
        \draw[->] (b) -- node[above,rotate=90,xshift=2.3em,yshift=-0.3em] {\cref{sec:low-level}} (c);
        \draw[->] (c) -- node[above,rotate=90,xshift=2.7em,yshift=-0.3em] {\cref{sec:pullback}} (d);
    \end{tikzpicture}
\end{center}

\paragraph{Related work.} The correspondence between subsets of string to
string functions and first order logic dates back to the origins of automata
theory and the seminal results of \cite{PEPI86,SCHU65,MNPA71}, establishing the
equivalence between \emph{star-free languages}, \emph{first order definable
languages}, and \emph{counter free automata}. Extensions of this correspondence
to functions has been an active area of research (\cite{CADA15,MUSC19}), which
we leverage in this work via the theory of \emph{polyregular functions}, a
model that can be traced back to the work of \cite{ENMA02}, and whose theory
has been developed and polished by \cite{bojanczyk2018polyregular}.

Weakest preconditions \cite[Chapter 7]{WINSKEL93}.


\paragraph{Outline.}



