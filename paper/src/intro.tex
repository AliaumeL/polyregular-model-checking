% LTeX: language=EN
\section{Introduction}
\label{sec:intro}

The goal of this paper is to define a programming language that is expressive
enough to capture a wide range of \emph{string-to-string} functions, and yet
simple enough to be amenable to formal verification. Specifically, we want to
be able to verify Hoare triples of the form
$\hoaretriple{P}{\texttt{code}}{Q}$, where $P$ and $Q$ are predicates and
\texttt{code} is a program, meaning that whenever the input satisfies property
$P$, the output of the program satisfies property $Q$.

\paragraph{Regularity preserving programs.} \AP One particularly interesting
class of specifications in the case of string-to-string functions are
\emph{regular languages}, which can be efficiently verified using
automata-based techniques. We say that $f$ is \intro{regularity preserving} if
the pre-image of a regular language through $f$ is regular, i.e. if $f^{-1}(L)$
is regular for all regular languages $L$. For \kl{regularity preserving
functions}, the verification of a Hoare triple $\hoaretriple{L_P}{f}{L_Q}$ can
be reduced to the nonemptiness problem of the language $L_P \cap f^{-1}(L_Q)$,
where $L_P$ and $L_Q$ are regular languages. This is a well-studied problem in
the literature, and is at the core of several more involved techniques
\cite{ALCE11,CHLRW19,JLMR23}. One key limitation of this approach is that there
exists uncomputable \kl{regularity preserving functions}, and one has to
restrict to a class of functions for which pre-images of regular languages are
(relatively) efficiently computable. Usually, these classes come from
generalisation of automata models to fuctions, also known as
\emph{string-to-string transducers}.

\paragraph{String-to-string transducer models.} There is a wide variety of
models for string-to-string transducers \cite{MUSC19}, and one of the most
prominent ones is called \intro{linear regular functions}, that are
equivalently represented using two-way finite transducers (2DFTs)
\cite{RASCO59}, streaming-string-transducers (SSTs) \cite{ALUR11}, or linear
regular list functions \cite{BDK18}. Notably, Alur and Černý have been proven
that SSTs have a \PSPACE-complete model checking problem when the functions are
given as SSTs, and the specifications are themselves given as SSTs acceptors
\cite[Theorem 13]{ALCE11}. This was used for instance by Chen, Taolue, Hague,
Lin, Rümer and Wu to study \emph{path feasibility} in string-manipulating
programs \cite{CHLRW19}.

A related usage of regularity preservation of transducer models was used by
Jeż, Lin, Markgraf and Rümmer, who leveraged the \emph{rational functions} (a
strict subclass of \kl{linear regular functions}) to study programs
manipulating strings with infinite alphabets (such as numbers). In this
setting, the automata model has to be adapted to the presence of infinite
alphabets with an internal structure, which prevents the use of all \kl{linear
regular functions} as the latter are no longer \todo{Please write something
clever here about atoms}.

\AP The relatively old model of \intro{two-way deterministic transducers with
nested pebbles} \cite{ENMA02} has recently gained a lot of traction now that
several other characterizations have been obtained
\cite{bojanczyk2018polyregular,bojanczyk2019string}. This class of
\reintro{polyregular functions} generalize \kl{linear regular functions} by
allowing polynomial behaviour, and are much closer to real life string
manipulating programs. Note that for this extended model, being \kl{regularity
preserving} is tightly connected to being closed under function composition
\cite[Proposition III.3]{FIRELH25}, and this closure under composition was one of the surprising
conclusions of \cite{bojanczyk2018polyregular}. However, this result is of
theoretical nature (no implementation or complexity bounds are given), and
writing programs using any of the existing equivalent definitions of
\kl{polyregular functions} is cumbersome and error-prone.

Because \kl{polyregular functions} can easily encode formulas in first-order
logic on words with a linear blowup in size, and since the satisfiability
problem for such formulas is known to be \TOWER-complete \cite[Theorem
13.5]{REINH02}, one can expect that verifying \kl{polyregular functions} to be
quite complex. Furthermore, such a verification procedure will generalize the
results of \cite{ALCE11}, and those of \cite{CHLRW19} that are limited to
\kl{linear regular functions}.

\paragraph{MSO vs FO.} \AP Instead of regular languages, that are equivalently
defined using finite automata, monadic second order logic (MSO), finite monoid
recognition, or regular expressions \cite{buchi1960weak,KLEE56,TRAK66,SCHU61},
A cornerstone result of the theory is establishing the equivalence between
\emph{star-free languages}, \emph{first order definable languages}, and
\emph{counter free automata} \cite{PEPI86,SCHU65,MNPA71}. The advantage of
using a weaker computational model is twofold: first, it allows us to focus on
a simpler class of \kl{polyregular functions} that are themselves
\emph{star-free} (this notion has been extended to various classes of
transducers, see \cite{CADA15,BDK18,MUSC19,bojanczyk2018polyregular}), for
which implementations are easier to obtain. Second, it allows us to reduce the
satisfiability of a Hoare triple to the satisfiability of a first-order formula
on finite words. Since the latter is already a \TOWER-compete problem, having
the ability to use general purpose SMT solvers to discharge the proof
obligations could lead to \emph{incomplete} but \emph{faster} decision
procedures.

\paragraph{Contributions.} \AP In this paper, we introduce a high-level
programming language that allows to write \kl{star-free polyregular functions}
in a Python-like syntax, allowing for boolean variables, index variables, a
limited form of list variables, function calls and nested for-loops. The design
of such language must be done very carefully to not become too expressive,
which is ensured by a number of syntactic restrictions and a novel type system
for variable storing string indices. We then show that this language can be
compiled into one of the equivalent definitions of \kl{polyregular functions}
(namely, \kl{simple for-programs}), which does not allow for function calls nor
list variables. We also provide an implementation of the previously knownq
abstract result stating that \kl{polyregular functions} are \kl{regularity
preserving} (in the case of star-free functions and languages), being careful
about the complexity of the transformations. Finally, we reduce the
verification of Hoare triples to the satisfiability of first-order formulas on
words. Since we are using \kl{first-order logic} as a target language, we are
not restricted to using automata based tools like \intro{MONA} \cite{MONA01},
but can also employ general purpose SMT solvers like \intro{Z3} \cite{z3} and
\intro{CVC5} \cite{cvc5}, generating proof obligations in the \texttt{SMT-LIB}
format \cite{BARRETT17}.

All of the steps described above have been implemented in a \texttt{Haskell}
program, and tested it on a number of examples with encouraging
results.\footnote{An anonymized version of our code is available at
\repositoryUrl.}

\begin{itemize}
\item That being said, we are not a tool paper, and the implementation should
  be seen as a proof of concept.

\item Our initial tests, while promising, are not fully-fledged benchmarks

\item more benchmarks are needed to assess the viability of our approach.

\item and we are aware that there is room for 
optimizations both in the implementation and the way encoding used
to discharge the proof obligations when using SMT solvers.

\end{itemize}

\paragraph{Outline.} The structure of the paper is as follows. We introduce our
\kl{high-level language} in \cref{sec:high-level}. In \cref{sec:polyregular},
we recall the theory of \kl{polyregular functions} by introducing them in terms
of \kl{simple for-programs} and \kl{$\FO$-interpretations}. We will also
provide an efficient reduction of the verification of Hoare triples to the
satisfiability of a \kl{first-order formula on words} in \cref{sec:pullback}.
In order to verify \kl{for-programs}, we compile them into \kl{simple
for-programs} in \cref{sec:htl}, and then compile \kl{simple for-programs} into
\kl{$\FO$-interpretations} in \cref{sec:low-level}. 
%These steps 
%are summarized in the following diagram:
%\begin{center}
%    \begin{tikzpicture}[
%        syntaxNode/.style={
%                    rectangle, draw, 
%                    text width=5em, 
%                    text centered, 
%                    rounded corners, 
%                    minimum height=4em}
%    ]
%        %
%        % Write a tikz picture with nodes explaining the different 
%        % steps of the rewriting system 
%        % 
%        % (a) high-level language
%        % (b) simple for-programs
%        % (c) first-order string-to-string interpretations
%        % (c1) precondition
%        % (c2) postcondition
%        % (d) first-order formula
%        \node[syntaxNode] (a) {\kl{For-program}};
%        \node[syntaxNode, right=of a] (b)  {\kl{Simple for-program}};
%        \node[syntaxNode, right=of b] (c)  {\kl{$\FO$ interpretation}};
%        \node[syntaxNode, right=of c] (d) {\kl{First-order formula}};
%
%        \draw[->] (a) -- node[above,rotate=90,xshift=2.3em,yshift=-0.3em] {\cref{sec:htl}} (b);
%        \draw[->] (b) -- node[above,rotate=90,xshift=2.3em,yshift=-0.3em] {\cref{sec:low-level}} (c);
%        \draw[->] (c) -- node[above,rotate=90,xshift=2.7em,yshift=-0.3em] {\cref{sec:pullback}} (d);
%    \end{tikzpicture}
%\end{center}
Then, in \cref{sec:benchmarks}, we present
benchmarks of our implementation on various examples, discussing
the complexity of the transformations and the main bottlenecks of our approach.
Finally, we conclude in \cref{sec:conclusion} by discussing potential
optimizations and future work.

