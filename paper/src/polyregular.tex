% LTeX: language=EN
\newpage
\section{Polyregular Functions}
\label{sec:polyregular}

Our strategy for showing that \kl{high-level language} has decidable \kl{model checking},
is to show that is expressive power is captured by \intro{first-order polyregular functions} -- 
a class of transductions introduced in \cite{bojanczyk2018polyregular} whose model checking 
problem is decidable \cite[Theorem~1.7]{bojanczyk2018polyregular}. 
We provide two equivalent definitions of the \kl{first-order
polyregular functions}: one using \kl{first-order simple for-programs} \cite[p.
19]{bojanczyk2018polyregular} and one using the logical model of
\kl{first-order string-to-string interpretations} \cite[Definition
4]{bojanczyk2019string}, the equivalence of which 
was proven in
\cite{bojanczyk2018polyregular}.

To make the models more suitable for large alphabets (such as the Unicode
characters), we present them in a symbolic setting (which uses a simplified
version of the ideas presented in \cite{d2017power} or in
\cite[Section~3.1]{bojanczyk2023growth}). This will dramatically reduce the
size of the \kl{first-order string-to-string interpretations}, and in turn, of
the \kl{first-order formula} that we will feed to the solvers. We will prove in
\cref{sec:low-level} that every \kl{first-order simple for-programs} can be
transformed into a \kl{first-order string-to-string interpretation} in the
symbolic setting. We believe that the other inclusion should also hold,
but we do not prove it, as it is out of this paper's scope.

\subsection{Symbolic transductions}

\begin{wrapfigure}{r}{0.5\textwidth}
    \input{figs/swap_as_bs.tex}
    \caption{The \texttt{swapAsToBs} program.}
    \label{fig:swapAsToBs}
\end{wrapfigure}

\AP
Consider the program in \cref{fig:swapAsToBs}, which swaps all \texttt{a}s to
\texttt{b}s in a string. Even though it operates on the entire Unicode
alphabet, it only distinguishes between three types of characters: \texttt{a},
\texttt{b} and the rest.
To formalize this observation, we model the Unicode alphabet as an infinite set $\mathcal{D}$, and
we define a function $T : \mathcal{D}^* \to \mathcal{D}^*$ to be
\intro{supported by} a set $A \subseteq \mathcal{D}$, if for every function $f:
\mathcal{D} \to \mathcal{D}$ that does not touch elements of $A$ (i.e.
$\forall_{a\in A}, f^{-1}(a) = \{a\}$), it holds that:
\begin{equation*}
    \forall_{w} \quad T(f^*(w)) = f^*(T(w)) \quad ,
\end{equation*}
Where $f^*$ is the extension of $f$ to $\mathcal{D}^*$, defined by applying $f$
to every letter.

It is not hard to see that the functions defined by
\kl{high-level programs} (of type $\TOut[1] \to \TOut[1]$)
are supported by the finite set $A$ of letter constants that they use.
This is also going to be the case for the \kl{simple for-programs}. In
\cref{subsec:fo-string-to-string}, we will define a version of the
\kl{first-order string-to-string interpretations} in a way that only depends on
the size of their support $A$, and not on the number of the Unicode characters.

\subsection{First-Order Simple For-Programs}

\AP \intro{First-order simple for-programs} is a simple programming language
that can be seen as a simplified\footnote{Actually, the \kl{high-level
language} was designed as an extended version \kl{first-order simple
for-programs}.} version of the \kl{high-level language}. The main difference is
that the \kl{simple for-programs} only define transductions of type $\TOut[1]
\to \TOut[1]$. 
Here is an example in a Python syntax:

\input{figs/reverse_words_simple.tex}

We disallow constructing intermediate word-values, there are no variables of
type $\TOut[n]$ for any $n$, and it is not possible to define functions (other
than the main function). As a consequence, the
for-loops can only iterate over the positions of the input word as in
\circleref{1}{sfp:for1} and \circleref{2}{sfp:for2}.
The label of a position can be accessed using the keyword $\mathsf{label}$, 
whether when testing it (\circleref{5}{sfp:labelTest}) or when printing it in
(\circleref{6}{sfp:labelPrint}).
As we are considering a restriction of the \kl{high-level language}, we only allow comparing labels
to constant characters (\ref{item:equality-checks}).
Finally, we only allow introducing boolean
variables at the top of the program (\circleref{1}{sfp:boolDeclTop}) or at the
beginning of a for loop (\circleref{3}{sfp:boolDeclFor}). 

\subsection{First-Order String-To-String Transductions}
\label{subsec:fo-string-to-string}

\AP The \kl{first-order string-to-string interpretations} is another model 
that defines functions $\mathcal{D}^* \to \mathcal{D}^*$. It is based on the \kl{first-order logic on words},
so before we present its definition, we recall the definition of the logic: The \intro{first-order logic on words}
consists of formulas described by \cref{fig:fo-syntax}.
\begin{figure}[h]
    \centering
    \begin{align*}
        \varphi,\ \psi :=&~ \forall_x\; \varphi ~|~ \exists_x\; \varphi ~|~ \varphi \wedge \psi ~|~ \varphi \vee \psi ~|~ \neg \varphi \\
                |&~ x = y ~|~ x < y ~|~ x =_L \mathtt{a} \textrm{, where } \mathtt{a} \in \mathcal{D}
    \end{align*}
    \caption{First-order logic on words.}
    \label{fig:fo-syntax}
\end{figure}
To evaluate such a formula $\varphi$ on a word $w \in \mathcal{D}^*$ we perform the quantifications
over the positions in $w$. The predicates $x = y$ and $x < y$ have the natural 
meaning, and $x =_L \mathtt{a}$ is checks if the $x$-th letter of $w$ is equal to $\mathtt{a}$.
An important property of this logic, it that it has decidable \kl{emptiness}, i.e. given a formula
$\varphi$ one can decide if there is a word $w$ such that $\varphi$ holds for $w$. For finite alphabets,
this property is well-know \cite{buchi1960weak}, and for the infinite alphabet $\mathcal{D}$ it is 
the consequence of the finite-alphabet case:
\begin{lemma}
    \label{lem:fo-emptiness}
    The \kl{emptiness} problem for the \kl{first-order logic on words} is decidable for the infinite alphabet $\mathcal{D}$.
\end{lemma}
\begin{proof}
    Take a formula $\varphi$ and observe that is contains only a finite number of constants from $\mathcal{D}$ -- call this set $A$.
    It is not hard to see that the truth value of $\varphi$ is \kl{supported} by $A$: for every function $f : \mathcal{D} \to \mathcal{D}$
    that does not touch 
    elements of $A$, the truth value of $\varphi$ is the same for $w$ and $f^*(w)$. (Remember that 
    $f^*$ is the pointwise application of $f$). 
    Let $\mathtt{blank} \in \mathcal{D}$ be a letter that does not appear in $A$,
    and observe that the formula $\varphi$ is satisfied for some word in $\mathcal{D}^*$ if and only if it is satisfied by
    some word in $(A \cup \{\mathtt{blank}\})^*$. Indeed, if we take a function $g: \mathcal{D} \to \mathcal{D}$ that does not touch elements of $A$
    and maps all other letters to $\mathtt{blank}$, we can use it to map $\mathcal{D}^*$ to $(A \cup \{\mathtt{blank}\})^*$ in a way 
    that preserves the truth value of $\varphi$.
    This finishes the proof of the lemma, as we have reduced the general problem to a finite alphabet $A \cup \{\mathtt{blank}\}$.
\end{proof}

\noindent
We are now ready to define the \kl{first-order string-to-string interpretations}.
\begin{definition}
A \intro{first-order string-to-string interpretation} consists of:
\begin{enumerate}
\item A finite set of \intro{character constants} $A \subset_{\textrm{fin}}\mathcal{D}$.
\item A finite set $T$ of \intro(transduction){tags}.
\item An \intro{arity function} $\mathsf{ar} : T \to \Nat$.
\item An \intro{output function} $\mathsf{out} : T \to A + \{1, \ldots, \mathsf{ar}(t)\}$. 
\item A \intro{domain formula} $\varphi_{\mathsf{dom}}^t(x_1,\ldots,x_{\mathsf{ar}(t)})$ 
    for every tag $t \in T$.
\item An \intro{order formula} $\varphi_{\leq}^{t,t'}(x_1,\ldots,x_{\mathsf{ar}(t)},y_1,\ldots,y_{\mathsf{ar}(t')})$ for every $t,t' \in T$. 
\end{enumerate}
The \kl(formula){order} and \kl(formula){domain} formulas should only use constants from $A$.
\end{definition}
\noindent
The interpretation's output for a word $w \in \mathcal{D}^*$ is obtained by the following process:
\begin{enumerate}
    \item  Take the set $P = \{1, \ldots, |w|\}$ of the positions in $w$, and construct the set 
           of \emph{elements} as the set $T(P) = (t : T) \times P^{\mathsf{ar}(t)}$
           of all tags from $T$ equipped with position tuples of the appropriate arity.
    \item Filter out the elements that do not satisfy the domain formula.
    \item Sort the remaining elements according to the order formula. Typically, we 
          want the order formula to define a total order on the remaining elements of $T(P)$ -- 
          if this is not the case, the interpretation return an empty word.
    \item Assign a letter to each element according to the output function: For an 
          element $t(p_1, \ldots, p_k)$, we look at of $\text{out}(t)$: If it returns $a \in A$
          the output letter is $a$. If it returns $i \in \{1, \ldots, k\}$, we copy the output letter from the
          $p_i$-th position of the input.
          
\end{enumerate}

For example, let us present a \kl{first-order word-to-word interpretation} for the function \texttt{swapAsToBs}. 
It has two tags \texttt{printB} and \texttt{copy}, both of arity~$1$. 
The element $\mathtt{printB}(x)$ outputs the letter \texttt{b} and the tag $\mathtt{copy}(x)$
outputs the letter of $x$-th position of the input word:
\[
\begin{tabular}{ccc}
    $\text{out}(\mathtt{printB}) = \mathtt{b}$ & \ \ \ & $\text{out}(\mathtt{copy}) = 1$ \\
\end{tabular}
\]
The element $\mathtt{printB}(x)$ is present in the output if $x$ is labelled with the letter \texttt{b}
in the input, otherwise the element $\mathtt{copy}(x)$ is present:
\[
\begin{tabular}{ccc}
    $\varphi_{\text{dom}}^{\mathtt{printB}}(x) : x =_L \mathtt{b}$ & \ \ \  &$\varphi_{\text{dom}}^{\mathtt{copy}}(x) : x \neq_L \mathtt{b}$ \\
\end{tabular}
\]
The tags are sorted by their positions, with ties resolved in favour of \texttt{printB}:
\[ 
\begin{tabular}{c|cc}
    $\varphi_{\leq}$ & $\mathtt{printB}(x_1)$ & $\mathtt{copy}(x_1)$ \\
    \hline
    $\mathtt{printB}(x_2)$ & $x_1 \leq x_2$ & $x_1 < x_2$ \\
    $\mathtt{copy}(x_2)$ & $x_1 \leq x_2$ & $x_1 \leq x_2$ \\
\end{tabular}
\]

\subsection{Hoare Triple Verification}

An important property of the \kl{first-order string-to-string interpretations} is that they a direct
reduction of the \kl{first-order Hoare triple verification} problem to the \kl{emptiness problem} for the \kl{first-order logic on words}:
\begin{definition}
    The \intro{first-order Hoare triple verification problem} for a \kl{first-order string-to-string interpretation} is the following decision problem: 
    \[
        \begin{tabular}{ll}
        \textbf{Input:} & A string-to-string interpretation $F$, and two first-order formulas $\varphi$ and $\psi$.\\
        \textbf{Output:} & Does $F(w)$ satisfy $\psi$ for every word $w$ that satisfies $\varphi$?
        \end{tabular}
    \]
    The instance of this problem is called a \intro{Hoare triple} and is denoted as $\{ \varphi \}\; F\; \{ \psi \}$. 
\end{definition}
For example, if \texttt{containsAB} and \texttt{containsBB} are formulas that check if the input word contains the
subwords \texttt{ab} and \texttt{bb}, then:
\[
\begin{tabular}{ccc}
$\{ \mathtt{containsAB} \}\ \texttt{swapAsToBs}\ \{ \mathtt{containsBB} \}$ & is  valid\\
$\{ \mathtt{containsBB} \}\ \mathtt{swapAsToBs}\ \{ \mathtt{containsAB} \}$ & is not  valid
\end{tabular}
\]
The decidability of the \kl{Hoare triple verification problem} for \kl{string-to-string first-order interpretations},
follows from \cite[Theorem~1.7]{bojanczyk2018polyregular}. However, this construction resulting from the proof is not practical to implement.
Instead, we provide a direct construction of a first-order formula $\chi(\phi, F, \psi)$
that is \kl{unsatisfiable} if and only if the triple $\{ \phi \}\; F\; \{ \psi \}$ is valid.
Moreover, the size and the quantifier depth of $\chi$ are bounded by the following low-degree polynomials:
\begin{align*}
    \qrank(\chi) \leq \max\left(\qrank(\phi),\ \qrank(\psi) \cdot \left(\textsf{ar}(F) + 1\right)  + \qrank(F)\right) \quad |\chi| = \mathcal{O} (|\phi| + |F| \cdot |\psi|)
\end{align*}

Here $|F|$ denotes the sum of the formulas in $F$,
$\qrank(F)$ denotes quantifier depth of the deepest formula in $F$, 
and $\textsf{ar}(F)$ denotes the maximal arity of the tags in $F$.


The most important element of the construction of $\chi$ is the \intro{pull-back operation}.
It transforms the formula $\psi$ applied to the output $F$,
to a formula $\pi(F, \psi)$ that can be applied directly the input word, 
such that for every word $w$:
\[
\begin{tabular}{ccc}
    $F(w)$ satisfies $\psi$ & $\Leftrightarrow$ & $w$ satisfies $\pi(F, \psi)$
\end{tabular}
\]
Once we have the pull-back operation, we can construct the formula $\chi$ as follows:
\[ 
    \chi(\phi, F, \psi)\ :=\ \phi \wedge \neg \pi(F, \psi)
\]
Indeed, a word $w$ satisfies $\phi \wedge \neg \pi(F, \psi)$ if and only if
it satisfies $\phi$ and $F(w)$ does not satisfy $\psi$. This means that 
$\chi$ is \kl{empty} if and only if the \kl{Hoare triple} is valid.

In the rest of this section, we show how to construct $\pi(F, \psi)$. 
The construction, is practically suggested by the definition of
\kl{first-order string-to-string interpretations}, so the main difficulty 
is to kep the size of the formula $\pi(F, \psi)$ small.
Every position from $F(w)$ corresponds to a tag $t$ and a tuple of $\mathsf{ar}(t)$, 
so the initial idea is to replace each quantification in $\psi$ with a conjunction or disjunction
over the tags. For example: 
\[ 
\begin{tabular}{ccc}
    $\forall_{x}, \psi$ & $\quad \rightsquigarrow \quad$ & $\bigwedge_{t_x \in T} \forall_{x_1, \ldots, x_{\mathsf{ar}(t)}} \left( \varphi_{\mathsf{dom}}^t(x_1, \ldots, x_{\mathsf{ar}(t)}) \Rightarrow \psi'_{t} \right)$
\end{tabular}
\]
A similar transformation can be done for the existential quantification. Negation, conjunction, and disjunction are straight-forward to handle, so 
the remaining part is to handle the predicates $=$, $\leq$, and $=_L$. The $\leq$ predicate can be handled by consulting the order formula:
\[
\begin{tabular}{ccc}
    $x < y$ & $\quad \rightsquigarrow \quad$ & $\psi_{\leq}^{t_x, t_y}(x_1, \ldots, x_{\mathsf{ar}(t_x)}, y_1, \ldots, y_{\mathsf{ar}(t_y)})$
\end{tabular}
\]
Similarly the $=_L$ predicate can be handled by consulting the output function, and
$x = y$ predicate can be handled by comparing equality of the tags and the positions of $x$ and $y$. 

This construction, although correct, is unfortunately inefficient:  Replacing each quantification with a disjunction or conjunction
over tags, results in an exponential blow-up of the formula. In order to avoid this, we introduce 
and additional finite sort to the logic,
this introduces a new type of quantifiers, that allow us to quantify over the tags in a more efficient way: $\forall_{t \in T}, \varphi$ 
and $\exists_{t \in T}, \varphi$. This does not add expressive power to the logic, as the new quantifiers can be replaced by 
a finite conjunction (resp. disjunction) that goes trough the tags. However, they will allow us to construct the pull-back formula
in a more efficient way, that can be understood by the solvers (we discuss it in more details at the end of this section).
With the new sort of tags, we can pull-back the quantifiers in the following way: 
\[ 
\begin{tabular}{ccc}
   $ \pi(F, \forall_{x}, \psi)$ & $\quad = \quad$ & $\forall{t_x \in T} \forall_{x_1, \ldots, x_{\mathsf{ar}(F)}} \left( {\mathsf{dom}}(t_x, x_1, \ldots, x_{\mathsf{ar}(F)}) \Rightarrow \pi(F, \psi)\right)$
\end{tabular}
\]
Here $\mathsf{dom}$ the following is a predicate based on $\varphi_{\mathsf{dom}}$:
\begin{align*}
    \mathsf{dom}(t, x_1, \ldots, x_{\mathsf{ar}(t)}) :=&~ \bigvee_{t' \in T} \left( t = t' \wedge \varphi_{\mathsf{dom}}^{t'}(x_1, \ldots, x_{\mathsf{ar}(t')}) \right)
\end{align*}
The existential quantification can be handled in an analogous way. Boolean operations are again straight-forward: 
\begin{align*}
    \pi(F, \psi_1 \wedge \psi_2) = \pi(F, \psi_1) \wedge \pi(F, \psi_2) \quad \pi(F, \neg \psi) = \neg \pi(F, \psi)
\end{align*}
In order to check if $x \leq y$, we use a formula similar to $\mathsf{dom}$, but based on $\varphi_\leq$:
\begin{align*}
   \pi(F, x \leq y) & \ \ =  &~ \bigvee_{t_1, t_2 \in T} \left( t_x = t_1 \wedge t_y = t_2 \wedge \varphi_{\leq}^{t_1, t_2}(x_1, \ldots, x_{\mathsf{ar}(t_1)}, y_1, \ldots, y_{\mathsf{ar}(t_2)}) \right) \\
\end{align*}
Finally, to check if $x =_L \mathtt{a}$, we use a similar formula based on the output function, and to check if $x = y$ we compare the tags and all the positions. (The complete translation can be found in the appendix).


\subsubsection{Encoding tags} Finally, let us briefly discuss how we handle the tags in the formulas fed to solvers.
For the SMT-solvers, we use \kl{smtlib v2.6} format with logic set to \texttt{UFDTLIA}, which allows us to add finite sorts and quantify over them.
For the MONA solver, which only supports the sort of positions, we encode the tags as as the first $|T|$ positions of the input word.

% \begin{align*}
%     \mathsf{out}_{\mathtt{a}}(t, x_1, \ldots, x_{\mathsf{ar}(t)}) :=&~ \bigvee_{t' \in T} \left( t = t' \wedge \mathsf{out}(t') = \mathtt{a} \right)
% \end{align*}




% The rest of this section is devoted to the construction of the pullback formula $\pi(F, \psi)$.
% Observe that each position in $F(w)$ corresponds to a tag $t$ together with $\mathsf{ar}(t)$
% positions of the input, that satisfy the domain formula of $t$. For this reason, whenever 
% $\pi$ sees a quantification it needs to go through all tags $t$ and all possible positions $x_1, \ldots, x_{\mathsf{ar}(t)}$
% that satisfy the domain formula of $t$. For example $\pi(F, \forall_x. \psi)$ could get translated to:
% \begin{equation*}
%     (\forall_{x_1, \ldots, x_{\mathsf{ar}(t_1)}}, \ \varphi_{\mathsf{dom}}^{t_1}(x_1, \ldots, x_{\mathsf{ar}(t_1)}) \Rightarrow \psi'_{t_1} )\ \wedge \   \ldots\\
%     \wedge (\forall_{x_1, \ldots, x_{\mathsf{ar}(t_n)}}, \ \varphi_{\mathsf{dom}}^{t_n}(x_1, \ldots, x_{\mathsf{ar}(t_n)}) \Rightarrow \psi'_{t_n} ) 
% \end{equation*}
% The existential quantification can be  handled in a similar way. Whenever the formula $\psi$ wants to check if $x < y$, 
% it consults the order formula with the tags and positions that correspond to $x$ and $y$:
% \[ \psi_{\leq}^{t_x, t_y}(x_1, \ldots, x_{\mathsf{ar}(t_x)}, y_1, \ldots, y_{\mathsf{ar}(t_y)}) \]
% Similarly, when it wants to check if $x =_L \mathtt{a}$, it consults the output function $\psi_{\text{out}}$.

% However, replacing each quantification with a disjunction over tags, would result in an exponential blow-up of the formula. For this reason, we introduce 
% an additional finite sort to the logic, that will allow us to quantify over the tags in a more efficient way. The new quantifiers will be of the form: 
% $\forall_{t \in T} \varphi$ and $\exists_{t \in T} \varphi$. They do not add expressive power to the logic, as they can be replace by 
% a finite conjunction (resp. disjunction) that goes trough the tags. However, they will allow us to construct the pull-back formula
% in a more efficient way, without confusing the solvers. The final translation is given by the following formulas: 
% \begin{enumerate}
%     \item $\pi(F, \forall_x. \psi) = \forall_{t_x \in T} \forall_{x_1, \ldots, x_{\mathsf{x_n}}} \left( \mathsf{dom}(t_x, x_1, \ldots, x_{\mathsf{t}})\Rightarrow \psi'_{t_x} \right)$\\
%     \item $\pi(F, \exists_x. \psi) = \exists_{t_x \in T} \exists_{x_1, \ldots, x_{\mathsf{x_n}}} \left( \mathsf{dom}(t_x, x_1, \ldots, x_{\mathsf{t}})\wedge \psi'_{t_x} \right)$\\
%     \item $\pi(F, \psi_1 \wedge \psi_2) = \pi(F, \psi_1) \wedge \pi(F, \psi_2)$\\
%     \item $\pi(F, \psi_1 \vee \psi_2) = \pi(F, \psi_1) \vee \pi(F, \psi_2)$\\
%     \item $\pi(F, \neg \psi) = \neg \pi(F, \psi)$\\
%     \item $\pi(F, x = y) = x_t = y_t \wedge x_1 = y_1 \ldots x_k = y_k$\\
%     \item $\pi(F, x < y) = \mathsf{order}(x_t, y_t, x_1, \ldots, x_k, y_1, \ldots, y_k)$\\
%     \item $\pi(F, x =_L \mathtt{a}) = \mathsf{out}_{\mathtt{a}}(x_t, x_1, \ldots, x_k)$\\
% \end{enumerate}
% Here the formulas $\mathsf{dom}$, $\mathsf{order}$ and $\mathsf{out}_{\mathtt{a}}$ are defined in the following way: 
% \begin{enumerate}
%     \item $\mathsf{dom}(x_t, x_1, \ldots, x_{\mathsf{t}}) = \bigvee_{t \in T} \left( t = x_t \wedge \varphi_{\mathsf{dom}}^t(x_1, \ldots, x_{\mathsf{ar}(t)}) \right)$\\ 
%     \item $\mathsf{order}(x_t, y_t, x_1, \ldots, x_{\mathsf{t}}, y_1, \ldots, y_{\mathsf{t}}) = \bigvee_{t, t' \in T} \left( t = x_t \wedge t' = y_t \wedge \varphi_{\leq}^{t, t'}(x_1, \ldots, x_{\mathsf{ar}(t)}, y_1, \ldots, y_{\mathsf{ar}(t')}) \right)$\\
%     \item $\mathsf{out}_{\mathtt{a}}(x_t, x_1, \ldots, x_{\mathsf{t}}) = \bigvee_{t \in T} \left( t = x_t \wedge () \right)$\\
% \end{enumerate}
