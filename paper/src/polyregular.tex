% LTeX: language=EN
\newpage
\section{Polyregular Functions}
\label{sec:polyregular}

Our strategy for showing that \kl{high-level language} has decidable \kl{model checking},
is to show that is expressive power is captured by \intro{first-order polyregular functions} -- 
a class of transductions introduced in \cite{bojanczyk2018polyregular} whose model checking 
problem is decidable \cite[Theorem~1.7]{bojanczyk2018polyregular}. 
We provide two equivalent definitions of the \kl{first-order
polyregular functions}: one using \kl{first-order simple for-programs} \cite[p.
19]{bojanczyk2018polyregular} and one using the logical model of
\kl{first-order string-to-string interpretations} \cite[Definition
4]{bojanczyk2019string}, the equivalence of which 
was proven in
\cite{bojanczyk2018polyregular}.

To make the models more suitable for large alphabets (such as the Unicode
characters), we present them in a symbolic setting (which uses a simplified
version of the ideas presented in \cite{d2017power} or in
\cite[Section~3.1]{bojanczyk2023growth}). This will dramatically reduce the
size of the \kl{first-order string-to-string interpretations}, and in turn, of
the \kl{first-order formula} that we will feed to the solvers. We will prove in
\cref{sec:low-level} that every \kl{first-order simple for-programs} can be
transformed into a \kl{first-order string-to-string interpretation} in the
symbolic setting. We believe that the other inclusion should also hold,
but we do not prove it, as it is out of this paper's scope.

\subsection{Symbolic transductions}

\begin{wrapfigure}{r}{0.55\textwidth}
    \input{figs/swap_as_bs.tex}
    \caption{The \texttt{swapAsToBs} program.}
    \label{fig:swapAsToBs}
\end{wrapfigure}

\AP
Consider the program in \cref{fig:swapAsToBs}, which swaps all \texttt{a}s to
\texttt{b}s in a string. Even though it operates on the entire Unicode
alphabet, it only distinguishes between three types of characters: \texttt{a},
\texttt{b} and the rest.
To formalize this observation, we model the Unicode alphabet as an infinite set $\mathcal{D}$, and
we define a function $T : \mathcal{D}^* \to \mathcal{D}^*$ to be
\intro{supported by} a set $A \subseteq \mathcal{D}$, if for every function $f:
\mathcal{D} \to \mathcal{D}$ that does not touch elements of $A$ (i.e.
$\forall_{a\in A}, f^{-1}(a) = \{a\}$), it holds that:
\begin{equation*}
    \forall_{w} \quad T(f^*(w)) = f^*(T(w)) \quad ,
\end{equation*}
Where $f^*$ is the extension of $f$ to $\mathcal{D}^*$, defined by applying $f$
to every letter.

It is not hard to see that the functions defined by
\kl{high-level programs} (of type $\TOut[1] \to \TOut[1]$)
are supported by the finite set $A$ of letter constants that they use.
This is also going to be the case for the \kl{simple for programs}. In
\cref{subsec:fo-string-to-string}, we will define a version of the
\kl{first-order string-to-string interpretations} in a way that only depends on
the size of their support $A$, and not on the number of the Unicode characters.

\subsection{First-Order Simple For-Programs}
\intro{First-order simple for-programs} is a simple programming language that can be be seen
as a simplified\footnote{Actually, the \kl{high-level language} was designed as an extended version \kl{first-order simple for-programs}.}
version of the \kl{high-level language}. The main difference is that the \kl{simple for-programs} only define transductions of type 
$\TOut[1] \to \TOut[1]$. Moreover, they disallow constructing intermediate word-values: There are no variables of type $\TOut[n]$, 
and it is not possible to define functions (other than the main function). As a consequence, the for-loops can only iterate over the input.
Here is an example:\\ 

% \emph{programs/reverse_words.spr}

It is not hard to see that programs written in this language define programs $f : \mathcal{D}^* \to \mathcal{D}^*$ that is supported by the 
finite set of letters used in the program (in this case this is a singleton containing the space character).

\subsection{First-Order String-To-String Transductions}
\label{subsec:fo-string-to-string}

\AP
In this section we describe a logical way of defining word-to-word functions: 
\begin{definition}
A \intro{first-order string-to-string interpretation} consists of:
\begin{enumerate}
\item A finite set $T$ of tags.
\item A finite set $A \subset_{\textrm{fin}}\mathcal{D}$.
\item An arity function $T \to \Nat$ assigning an arity to each tag.
\item An output function function $\text{out} : T \to A + \{1, \ldots, \text{arity}(t)\}$. 
\item A domain formula $\varphi_{\text{dom}}^t(x_1,\ldots,x_{\text{arity}(t)})$ for every tag $t \in T$.
      The free variables represent positions in the input word, and can be queried using the predicates: 
      $x_i = x_j$, $x_i < x_j$, and $x_i =_L a$ for $a \in A$.
\item An order formula $\varphi_{\leq}^{t,t'}((x_1,\ldots,x_{\text{arity}(t)}),(y_1,\ldots,y_{\text{arity}(t')}))$ for every pair of tags $t,t' \in T$. 
      It can use the same predicates as the domain formula. 
\end{enumerate}
\end{definition}

Every interpretation defines a function $f : \mathcal{D}^* \to \mathcal{D}^*$ that is supported by $A$.
The output for a word $w$ is obtained by the following process:
\begin{enumerate}
    \item  Take the set $P = \{1, \ldots, |w|\}$ of the positions in $w$, and construct the set 
           of \emph{elements} as the set $T(P) = (t : T) \times P^{\text{arity}(t)}$
           of all tags from $T$ equipped with position tuples of the appropriate arity.
    \item Filter out the elements that do not satisfy the domain formula.
    \item Sort the remaining elements according to the order formula. Intuitively, we 
          want the order formula to define a total order on the elements of $T(P)$ that 
          were not filtered out by the domain formula -- if this is not the case,
          the interpretation return an empty word.
    \item Assign a letter to each element according to the output function.
          In order to choose the letter for an element $t(p_1, \ldots, p_k)$, we look at the 
          output of $\text{out}(t)$: if it is a letter $a \in A$ we simply choose it,
          and if it is $i \in \{1, \ldots, k\}$ we choose the $p_i$-th letter of the input word.
\end{enumerate}

For example, let us present a \kl{first-order word-to-word} interpretation that defines the function \texttt{swapAsToBs}. 
It has two tags \texttt{printB} and \texttt{copy}, both of arity~$1$. 
The element $\mathtt{printB}(x)$ outputs the letter \texttt{'a'} and the tag $\mathtt{copy}(x)$
outputs the letter of $x$-th position of the input word:
\[
\begin{tabular}{ccc}
    $\text{out}(\mathtt{printB}) = \mathtt{b}$ & \ \ \ & $\text{out}(\mathtt{copy}) = 1$ \\
\end{tabular}
\]
The element $\mathtt{printA}(x)$ is present in the output if $x$ is labelled with the letter \texttt{b}
in the input, otherwise the element $\mathtt{copy}(x)$ is present:
\[
\begin{tabular}{ccc}
    $\varphi_{\text{dom}}^{\mathtt{printA}}(x) : x =_L \mathtt{b}$ & \ \ \  &$\varphi_{\text{dom}}^{\mathtt{copy}}(x) : x \neq_L \mathtt{b}$ \\
\end{tabular}
\]
The tags are sorted by their positions, with ties resolved in favour of \texttt{printA}:
\[ 
\begin{tabular}{c|cc}
    $\varphi_{\leq}$ & $\mathtt{printA}(x_1)$ & $\mathtt{copy}(x_1)$ \\
    \hline
    $\mathtt{printA}(x_2)$ & $x_1 \leq x_2$ & $x_1 < x_2$ \\
    $\mathtt{copy}(x_2)$ & $x_1 \leq x_2$ & $x_1 \leq x_2$ \\
\end{tabular}
\]
